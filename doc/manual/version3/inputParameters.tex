\chapter{Input Parameters}
\label{ch:input}

\newcommand{\param}[5]{{\setlength{\parindent}{0cm} {\ttfamily \bfseries \hypertarget{#1}{#1}}\\{\it Type}: #2\\{\it Default}: #3\\{\it When it matters}: #4\\{\it Meaning}: #5}}
%%NOTE BY AM, the \param command does not work for defining parameters with an underscore in the name, for these parameters use \paramWithUnderscore.
\newcommand{\paramWithUnderscore}[6]{{\setlength{\parindent}{0cm} {\ttfamily \bfseries \hypertarget{#2}{#1}}\\{\it Type}: #3\\{\it Default}: #4\\{\it When it matters}: #5\\{\it Meaning}: #6}}
\newcommand{\ssparam}[4]{{\setlength{\parindent}{0cm} {\ttfamily \bfseries \hypertarget{#1}{#1}}\\{\it Type}: #2\\{\it When it matters}: #3\\{\it Meaning}: #4}}
\newcommand{\ssparamWithUnderscore}[5]{{\setlength{\parindent}{0cm} {\ttfamily \bfseries \hypertarget{#2}{#1}}\\{\it Type}: #3\\{\it When it matters}: #4\\{\it Meaning}: #5}}
\newcommand{\PETScParam}[2]{{\setlength{\parindent}{0cm} {\ttfamily \bfseries #1}\\{\it Meaning}: #2}}
\newcommand{\myhrule}{{\setlength{\parindent}{0cm} \hrulefill }}

\newcommand{\true}{{\ttfamily .true.}}
\newcommand{\false}{{\ttfamily .false.}}

In this chapter we first describe all the parameters which can be included in the {\ttfamily input.namelist} file. 
Then we list some of the command-line flags associated with \PETSc~which can be useful.
Note that all parameters in {\ttfamily input.namelist}, both for \sfincs~and \sfincsScan,
are case-insensitive.




\section{The {\ttfamily general} namelist}

The default values are usually best for the parameters in this namelist.

\myhrule

\param{RHSMode}
{integer}
{1}
{Always}
{Option related to the number of right-hand sides (i.e. inhomogeneous drive terms) for which the kinetic equation is solved.\\

{\ttfamily RHSMode} = 1: Solve for a single right-hand side.\\

{\ttfamily RHSMode} = 2: Solve for 3 right-hand sides to get the 3$\times$3 transport matrix. Presently implemented only for 1 species and \parlink{includePhi1} == \false\\

{\ttfamily RHSMode} = 3: Solve for the 2$\times$2 monoenergetic transport coefficients. When this option is chosen, \Nx~is set to 1, only 1 species is used and \parlink{includePhi1} is set to \false \\

{\ttfamily RHSMode} = 4: Solve the adjoint equation to compute derivatives at constant $E_r$. Options related to the adjoint solve are detailed in section \ref{sec:adjointOptions}. {\ttfamily RHSMode} = 4 must be used with \\ \parlink{includePhi1}=\false, \parlink{EParallelHat}\texttt{=0}, \parlink{magneticDriftScheme}\texttt{>0}, \\ \parlink{constraintScheme}\texttt{=-1} or 1, \parlink{collisionOperator}\texttt{=0}, and \parlink{geometryScheme}\texttt{/=5}. \\

{\ttfamily RHSMode} = 5: Solve the adjoint equation to compute derivatives at the ambipolar $E_r$. Options related to the adjoint solve are detailed in section \ref{sec:adjointOptions}. {\ttfamily RHSMode} = 5 must be used with \\ \parlink{includePhi1}=\false, \parlink{EParallelHat}\texttt{=0}, \parlink{magneticDriftScheme}\texttt{>0}, \\ \parlink{constraintScheme}\texttt{=-1} or 1, \parlink{collisionOperator}\texttt{=0}, and \parlink{geometryScheme}\texttt{/=5}. \\ 
}


\myhrule

\param{outputFileName}
{string}
{``sfincsOutput.h5''}
{Always}
{Name which will be used for the HDF5 output file.  If this parameter is changed from the default value, \sfincsScan~ will not work.}

\myhrule

\param{saveMatlabOutput}
{Boolean}
{\false}
{Always}
{If this switch is set to true, Matlab m-files are created which
 store the system matrix, right-hand side, and solution vector.  If an iterative solver is used,
 the preconditioner matrix is also saved.
 PETSc usually generates an error message if you ask to save Matlab output when
the size of the linear system is more then 1400 $\times$ 1400,
 so usually this setting should be false except for very small test problems.
}

\myhrule

\param{MatlabOutputFilename}
{string}
{``sfincsMatrices''}
{Only when \parlink{saveMatlabOutput} == \true.}
{Start of the filenames which will be used for Matlab output.}

\myhrule

\param{saveMatricesAndVectorsInBinary}
{Boolean}
{\false}
{Always}
{If this switch is set to true, the matrix, right-hand-side, and solution vector of the
linear system will be saved in PETSc's binary format.  
The preconditioner matrix will also
be saved if \parlink{useIterativeLinearSolver} == \true.}
These matrices and vectors are not very interesting for routine use of the code,
only for code development and debugging.
Regardless of how this parameter is set,
the physically interesting input and output quantities will be saved in a
separate \HDF~file.

\myhrule

\param{binaryOutputFilename}
{string}
{``sfincsBinary''}
{Only when \parlink{saveMatricesAndVectorsInBinary} == \true.}
{Start of the filenames which will be used for binary output of the system
matrices, right-hand-side vectors, and solution vectors.
These matrices and vectors are not very interesting for routine use of the code,
only for code development and debugging.
Regardless of how this parameter is set,
the physically interesting input and output quantities will be saved in a
separate \HDF~file.
}

\myhrule

\param{solveSystem}
{Boolean}
{\true}
{Always}
{If this parameter is false, the system of equations will not actually be solved.
 Sometimes it can be useful to set this parameter to \false~when debugging.
}

\myhrule

\param{ambipolarSolve}
{Boolean}
{\false}
{When \parlink{RHSMode}==1, 4, or 5.}
{When \true, a root finding method will be used to find the ambipolar \parlink{Er}. All output parameters will be included at the ambipolar \parlink{Er}. Options related to this parameter are \parlink{NEr\_ambipolarSolve}, \parlink{Er\_search\_tolerance\_dx}, \parlink{Er\_search\_tolerance\_f}, \\ \parlink{ambipolarSolveOption}, \parlink{Er\_min}, and \parlink{Er\_max}.}

\myhrule

\param{NEr\_ambipolarSolve}
{integer}
{20}
{When \parlink{ambipolarSolve} == \true.}
{Maximum number of solves to allow while finding the ambipolar \parlink{Er}.}

\myhrule

\param{Er\_search\_tolerance\_dx}
{real}
{1.d-8}
{When \parlink{ambipolarSolve} == \true and \parlink{ambipolarSolveOption}/=2.}
{Tolerance used for ambipolar solve. If step size in \parlink{Er} falls below \parlink{Er\_search\_tolerance\_dx}, the ambipolar solve completes successfully. Note that this is not used for \parlink{ambipolarSolveOption}==2.}

\myhrule

\param{Er\_search\_tolerance\_f}
{real}
{1.d-10}
{When \parlink{ambipolarSolve} == \true.}
{Tolerance used for ambipolar solve. If the radial current,
\begin{gather}
J_r = \sum_s \texttt{Zs}(s) \texttt{particleFlux\_vm\_rN}(s),
\end{gather}
falls below \parlink{Er\_search\_tolerance\_f}, the ambipolar solve completes successfully.}

\myhrule

\param{ambipolarSolveOption}
{integer}
{1}
{When \parlink{ambipolarSolve} == \true}
{Indicates which root solving algorithm to use for ambipolar solve. \\
\parlink{ambipolarSolveOption}==1: a Newton bisection method is used \\ 
\parlink{ambipolarSolveOption}==2: a Brent method is used \\
\parlink{ambipolarSolveOption}==3: a Newton method is used. 

If \parlink{ambipolarSolveOption}==1 or 3, an adjoint method will used to compute the $\partial J_r/\partial E_r$, so must be used with \parlink{includePhi1}==\false, \parlink{EParallelHat}==0, \parlink{magneticDriftScheme}$>0$, \parlink{constraintScheme}==-1 or 1, and \parlink{collisionOperator}==0.}

\myhrule

\param{Er\_min}
{real}
{-100}
{When \parlink{ambipolarSolve} == \true and \parlink{ambipolarSolveOption} /= 3. }
{Minimum value of \parlink{Er} used to bracket the ambipolar root. }

\myhrule

\param{Er\_max}
{real}
{100}
{When \parlink{ambipolarSolve} == \true and \parlink{ambipolarSolveOption} /= 3. }
{Maximum  value of \parlink{Er} used to bracket the ambipolar root. }

\myhrule

\section{The {\ttfamily geometryParameters} namelist}
\label{sec:geometryParameters}

The parameters in this namelist define the magnetic geometry, and so you will almost certainly want to modify some of these parameters.

\myhrule

\param{geometryScheme}
{integer}
{1}
{Always}
{How the magnetic geometry is specified.\\

{\ttfamily geometryScheme}==1: Use the following 3-helicity model:\\
\begin{eqnarray}
\label{eq:Bmodel}
B(\theta,\zeta)/\bar{B} 
&=& (\mbox{\parlink{B0OverBBar}}) [1 + (\mbox{\underscoreparlink{epsilon\_t}{epsilon_t}}) \cos(\theta) \\
&& + (\mbox{\underscoreparlink{epsilon\_h}{epsilon_h}}) \cos((\mbox{\underscoreparlink{helicity\_l}{helicity_l}}) \theta - (\mbox{\underscoreparlink{helicity\_n}{helicity_n}}) \zeta) \nonumber \\
&&  + (\mbox{\underscoreparlink{epsilon\_antisymm}{epsilon_antisymm}}) \nonumber \\
&& \times \sin((\mbox{\underscoreparlink{helicity\_antisymm\_l}{helicity_antisymm_l}}) \theta - (\mbox{\underscoreparlink{helicity\_antisymm\_n}{helicity_antisymm_n}}) \zeta)] \nonumber
\end{eqnarray}

(All the variables in this formula are discussed later in this namelist.)\\

{\ttfamily geometryScheme}==2: Use a 3-helicity model of the LHD standard configuration at {\ttfamily rN}=0.5.\\

{\ttfamily geometryScheme}==3: Use a 4-helicity model of the LHD inward-shifted configuration at {\ttfamily rN}=0.5.\\

{\ttfamily geometryScheme}==4: Use a 3-helicity model of the W7-X standard configuration at {\ttfamily rN}=0.5.\\

{\ttfamily geometryScheme}==5: Read the {\ttfamily vmec wout} file specified in \parlink{equilibriumFile} below. The file can be
       either ASCII format or \netCDF~format. (\sfincs~will auto-detect the format.).\\

{\ttfamily geometryScheme}==11: Read the IPP {\ttfamily .bc} format Boozer-coordinate file specified in \parlink{equilibriumFile} below. 
The file is assumed to be stellarator-symmetric.\\

{\ttfamily geometryScheme}==12: Read the IPP {\ttfamily .bc} format Boozer-coordinate file specified in \parlink{equilibriumFile} below. 
The file is assumed to be stellarator-\emph{asymmetric}.

{\ttfamily geometryScheme}==13: Read Boozer geometry from the {\ttfamily geometryParamters} namelist. Here the geometry parameters are specified by \parlink{Nperiods}, \parlink{boozer\_bmnc}, \parlink{GHat}, \parlink{IHat}, and \parlink{iota}. This has been implemented for use with STELLOPT for direct optimization of the Boozer spectrum. 
}

\myhrule

\param{inputRadialCoordinate}
{integer}
{3}
{When \parlink{geometryScheme} == 1, 5, 11, or 12}
{Which radial coordinate to use to specify the flux surface for a single calculation,
or to specify the range of flux surfaces for a radial scan. 
(Regardless of the value of this parameter, when \parlink{geometryScheme} == 2, 3, or 4, the flux surface used will be {\ttfamily rN}=0.5.)
See section \ref{sec:radialCoordinates}
for more information about radial coordinates.\\

{\ttfamily inputRadialCoordinate}==0: Use the flux surface specified by \underscoreparlink{psiHat\_wish}{psiHat_wish}
for a single run, and use the range specified by \underscoreparlink{psiHat\_min}{psiHat_min} and \underscoreparlink{psiHat\_max}{psiHat_max} for radial scans.\\

{\ttfamily inputRadialCoordinate}==1: Use the flux surface specified by \underscoreparlink{psiN\_wish}{psiN_wish}
for a single run, and use the range specified by \underscoreparlink{psiN\_min}{psiN_min} and \underscoreparlink{psiN\_max}{psiN_max} for radial scans.\\

{\ttfamily inputRadialCoordinate}==2: Use the flux surface specified by \underscoreparlink{rHat\_wish}{rHat_wish}
for a single run, and use the range specified by \underscoreparlink{rHat\_min}{rHat_min} and \underscoreparlink{rHat\_max}{rHat_max} for radial scans.\\

{\ttfamily inputRadialCoordinate}==3: Use the flux surface specified by \underscoreparlink{rN\_wish}{rN_wish}
for a single run, and use the range specified by \underscoreparlink{rN\_min}{rN_min} and \underscoreparlink{rN\_max}{rN_max} for radial scans. \\

No matter which option you pick, the value of all 4 radial coordinates used will be saved in the output \HDF~file.
}

\myhrule

\param{inputRadialCoordinateForGradients}
{integer}
{4}
{Whenever \parlink{RHSMode}==1.}
{Which radial coordinate is used to use to specify the input gradients of density, temperature, and electrostatic potential,
i.e. which radial coordinate is used in the denominator of these derivatives.
See section \ref{sec:radialCoordinates}
for more information about radial coordinates.\\

{\ttfamily inputRadialCoordinateForGradients}==0: Density gradients are specified by \parlink{dnHatdpsiHats},
temperature gradients are specified by \parlink{dTHatdpsiHats}, a single $E_r$ is specified by \parlink{dPhiHatdpsiHat},
and the range of an $E_r$ scan is specified by \parlink{dPhiHatdpsiHatMin}-\parlink{dPhiHatdpsiHatMax}.\\

{\ttfamily inputRadialCoordinateForGradients}==1: Density gradients are specified by \parlink{dnHatdpsiNs},
temperature gradients are specified by \parlink{dTHatdpsiNs}, a single $E_r$ is specified by \parlink{dPhiHatdpsiN},
and the range of an $E_r$ scan is specified by \parlink{dPhiHatdpsiNMin}-\parlink{dPhiHatdpsiNMax}.\\

{\ttfamily inputRadialCoordinateForGradients}==2: Density gradients are specified by \parlink{dnHatdrHats},
temperature gradients are specified by \parlink{dTHatdrHats}, a single $E_r$ is specified by \parlink{dPhiHatdrHat},
and the range of an $E_r$ scan is specified by \parlink{dPhiHatdrHatMin}-\parlink{dPhiHatdrHatMax}.\\

{\ttfamily inputRadialCoordinateForGradients}==3: Density gradients are specified by \parlink{dnHatdrNs},
temperature gradients are specified by \parlink{dTHatdrNs}, a single $E_r$ is specified by \parlink{dPhiHatdrN},
and the range of an $E_r$ scan is specified by \parlink{dPhiHatdrNMin}-\parlink{dPhiHatdrNMax}.\\

{\ttfamily inputRadialCoordinateForGradients}==4: 
Same as {\ttfamily inputRadialCoordinateForGradients}==2, except \parlink{Er} is used instead of \parlink{dPhiHatdrHat}.
Thus, density gradients are specified by \parlink{dnHatdrHats},
temperature gradients are specified by \parlink{dTHatdrHats}, a single $E_r$ is specified by \parlink{Er},
and the range of an $E_r$ scan is specified by \parlink{ErMin}-\parlink{ErMax}.\\

No matter which option you pick, the gradients with respect to all radial coordinates will be saved in the output \HDF~file.
}

\myhrule

\paramWithUnderscore{psiHat\_wish}{psiHat_wish}
{real}
{-1}
{Only when \parlink{inputRadialCoordinate} == 0 and \parlink{geometryScheme} == 1, 5, 11, or 12.}
{Requested flux surface for the computation.  See section \ref{sec:radialCoordinates}
for more information about radial coordinates.}

\myhrule

\paramWithUnderscore{psiN\_wish}{psiN_wish}
{real}
{0.25}
{Only when \parlink{inputRadialCoordinate} == 1 and \parlink{geometryScheme} == 1, 5, 11, or 12.}
{Requested flux surface for the computation.  See section \ref{sec:radialCoordinates}
for more information about radial coordinates.}

\myhrule

\paramWithUnderscore{rHat\_wish}{rHat_wish}
{real}
{-1}
{Only when \parlink{inputRadialCoordinate} == 2 and \parlink{geometryScheme} == 1, 5, 11, or 12.}
{Requested flux surface for the computation.  See section \ref{sec:radialCoordinates}
for more information about radial coordinates.}

\myhrule

\paramWithUnderscore{rN\_wish}{rN_wish}
{real}
{0.5}
{Only when \parlink{inputRadialCoordinate} == 3 and \parlink{geometryScheme} == 1, 5, 11, or 12.}
{Requested flux surface for the computation.  See section \ref{sec:radialCoordinates}
for more information about radial coordinates.}

\myhrule

\param{B0OverBBar}
{real}
{1.0}
{Only when \parlink{geometryScheme} == 1. Otherwise, {\ttfamily B0OverBBar} will be set according to the requested \parlink{geometryScheme}.}
{Magnitude of the (0,0) Boozer harmonic of the magnetic field strength (equivalent to $\left< B^3\right>/\left<B^2\right>$), normalized by $\bar{B}$.}

\myhrule

\param{GHat}
{real}
{3.7481}
{Only when \parlink{geometryScheme} == 1. Otherwise, {\ttfamily GHat} will be set according to the requested \parlink{geometryScheme}.}
{$G$ is $(c/2)\times$ the poloidal current outside the flux
 surface. Equivalently, $G$ is the coefficient of $\nabla\zeta_B$ in the
 covariant representation of $\vect{B}$ in terms of Boozer coordinates $(\theta_B,\zeta_B)$:
\begin{equation}
\label{eq:covariant}
\vect{B}(\psi,\theta_B,\zeta_B) = \beta(\psi,\theta_B,\zeta_B)\nabla\psi + I(\psi)\nabla\theta_B + G(\psi)\nabla\zeta_B.
\end{equation}
{\ttfamily GHat} is $G$ normalized by $\bar{B}\bar{R}$.}

\myhrule

\param{IHat}
{real}
{0.0}
{Only when \parlink{geometryScheme} == 1. Otherwise, {\ttfamily IHat} will be set according to the requested \parlink{geometryScheme}.}
{$I$ is $(c/2)\times$ the toroidal current inside the flux
 surface. Equivalently, $I$ is the coefficient of $\nabla\theta_B$ in the
 covariant representation of $\vect{B}$ in terms of Boozer coordinates $(\theta_B,\zeta_B)$ in (\ref{eq:covariant}).
{\ttfamily IHat} is $I$ normalized by $\bar{B}\bar{R}$.}

\myhrule

\param{iota}
{real}
{0.4542}
{Only when \parlink{geometryScheme} == 1. Otherwise, {\ttfamily iota} will be set according to the requested \parlink{geometryScheme}.}
{Rotational transform (rationalized), equivalent to $1/q$ where $q$ is the safety factor.}

\myhrule

\paramWithUnderscore{epsilon\_t}{epsilon_t}
{real}
{-0.07053}
{Only when \parlink{geometryScheme} == 1.}
{Toroidal variation in $B$, as defined by (\ref{eq:Bmodel}).}

\myhrule

\paramWithUnderscore{epsilon\_h}{epsilon_h}
{real}
{0.05067}
{Only when \parlink{geometryScheme} == 1.}
{Helical variation in $B$, as defined by (\ref{eq:Bmodel}).}

\myhrule

\paramWithUnderscore{epsilon\_antisymm}{epsilon_antisymm}
{real}
{0.0}
{Only when \parlink{geometryScheme} == 1.}
{Stellarator-antisymmetric variation in $B$, as defined by (\ref{eq:Bmodel}).}

\myhrule

\paramWithUnderscore{helicity\_l}{helicity_l}
{integer}
{2}
{Only when \parlink{geometryScheme} == 1, or when simultaneously \parlink{geometryScheme} == 5 and \parlink{rippleScale} != 1.0.}
{Poloidal mode number of the helical variation in $B$, as defined by (\ref{eq:Bmodel}).}

\myhrule

\paramWithUnderscore{helicity\_n}{helicity_n}
{integer}
{10}
{Only when \parlink{geometryScheme} == 1, or when simultaneously \parlink{geometryScheme} == 5 and \parlink{rippleScale} != 1.0.}
{Toroidal mode number of the helical variation in $B$, as defined by (\ref{eq:Bmodel}).}

\myhrule

\paramWithUnderscore{helicity\_antisymm\_l}{helicity_antisymm_l}
{integer}
{1}
{Only when \parlink{geometryScheme} == 1.}
{Poloidal mode number of the stellarator-antisymmetric variation in $B$, as defined by (\ref{eq:Bmodel}).}

\myhrule

\paramWithUnderscore{helicity\_antisymm\_n}{helicity_antisymm_n}
{integer}
{0}
{Only when \parlink{geometryScheme} == 1.}
{Toroidal mode number of the stellarator-antisymmetric variation in $B$, as defined by (\ref{eq:Bmodel}).
Note that you can create an up-down asymmetric tokamak by setting \underscoreparlink{helicity\_antisymm\_n}{helicity_antisymm_n}=0, \underscoreparlink{epsilon\_h}{epsilon_h}=0,
and \underscoreparlink{epsilon\_antisymm}{epsilon_antisymm}$>$0.}

\myhrule

\param{psiAHat}
{real}
{0.15596}
{Only when \parlink{geometryScheme} == 1. Otherwise, {\ttfamily psiAHat} will be set according to the requested \parlink{geometryScheme}.}
{{\ttfamily psiAHat} = $\psi_a / (\bar{B} \bar{R}^2)$
where $2 \pi \psi_a$ is the toroidal flux at the last closed flux surface.}

\myhrule

\param{aHat}
{real}
{0.5585}
{Only when \parlink{geometryScheme} == 1. Otherwise, {\ttfamily aHat} will be set according to the requested \parlink{geometryScheme}.}
{The effective minor radius at the last closed flux surface, in units of $\bar{R}$.
The code only uses {\ttfamily aBar} for converting between the various radial coordinates in input and output quantities.
}

\myhrule

\param{equilibriumFile}
{string}
{``''}
{Only when \parlink{geometryScheme} == 5, 11, or 12.}
{Filename from which to load the magnetic equilibrium, either in {\ttfamily vmec wout} ASCII or \netCDF~format, or IPP {\ttfamily .bc} format.}

\myhrule

\param{VMECRadialOption}
{integer}
{1}
{Only when \parlink{geometryScheme} == 5, 11 or 12.}
{Controls whether the nearest available flux surface in the {\ttfamily
    vmec wout} file or {\ttfamily .bc} file is used, or whether radial interpolation is applied to the data
to obtain the magnetic field components on the exact surface requested.\\

{\ttfamily VMECRadialOption}=0: Use the exact {\ttfamily XXX\_wish} flux surface requested, by interpolating from the radial grid.\\

{\ttfamily VMECRadialOption}=1: Use a surface that may be slightly
different from {\ttfamily XXX\_wish} to get the nearest available flux
surface from \vmec's HALF grid (or the {\ttfamily .bc} file grid).  
   The components of $\vect{B}$ in \vmec~are stored on the half grid, so interpolation is then unnecessary.\\

{\ttfamily VMECRadialOption}=2: Use a surface that may be slightly different from {\ttfamily XXX\_wish} to get the nearest available flux surface from \vmec's FULL grid.
I'm not sure why you would want this, but the feature is implemented for completeness.
}

\myhrule

\paramWithUnderscore{VMEC\_Nyquist\_option}{VMEC_Nyquist_option}
{integer}
{1}
{Only when \parlink{geometryScheme} == 5.}
{In VMEC, some quantities are known at poloidal and toroidal mode numbers given by the arrays {\ttfamily xm} and
{\ttfamily xn}, whereas other quantities are known at a larger range of mode numbers {\ttfamily xm\_nyq} and {\ttfamily xn\_nyq}.
The sfincs parameter {\ttfamily VMEC\_Nyquist\_option}
controls whether or not to include mode numbers that exist in the {\ttfamily xm\_nyq} and {\ttfamily xn\_nyq}
arrays but not in the {\ttfamily xm} and {\ttfamily xn} arrays.
This parameter only affects high-frequency components of the magnetic field, results of sfincs
should not be very sensitive to this parameter.
\\

{\ttfamily VMEC\_Nyquist\_option}=1: Only include poloidal and toroidal mode numbers that exist
in the {\ttfamily xm} and {\ttfamily xn} arrays.  This option was always used prior to July 2017.\\

{\ttfamily VMEC\_Nyquist\_option}=2: Also include the larger poloidal and toroidal mode numbers that exist
in the {\ttfamily xm\_nyq} and {\ttfamily xn\_nyq} arrays, where available.
}

\myhrule

\paramWithUnderscore{min\_Bmn\_to\_load}{min_Bmn_to_load}
{real}
{0.0}
{Only when \parlink{geometryScheme} == 5, 11, or 12.}
{Filters the magnetic field read from an input file.  Only Fourier modes $(m,n)$ for which $B_{m,n}$ is at least {\ttfamily min\_Bmn\_to\_load} will be included.}

\myhrule

\param{rippleScale}
{real}
{1.0}
{Only when \parlink{geometryScheme} == 5. \underscoreparlink{helicity\_l}{helicity_l} and \underscoreparlink{helicity\_n}{helicity_n} must be specified.}
{Scales the values of components of VMEC geometry (modes of $B$, $B^{u}$, $B_{u}$, $B^{v}$, $B_{v}$, $B_{s}$, and $\sqrt{g}$) that do not satisfy a desired symmetry. If \underscoreparlink{helicity\_n}{helicity_n}$==0$, modes for which $n \neq 0$ or $m \neq$ \underscoreparlink{helicity\_l}{helicity_l} are multiplied by \parlink{rippleScale}. If \underscoreparlink{helicity\_n}{helicity_n}$\neq0$, modes for which $m/n \neq$ \underscoreparlink{helicity\_l}{helicity_l}/\underscoreparlink{helicity\_n}{helicity_n} or $n==0$ are multiplied by \parlink{rippleScale}. All other modes remain unchanged.}

\myhrule

\paramWithUnderscore{EParallelHatSpec\_bcdatFile}{EParallelHatSpec_bcdatFile}
{string}
{``''}
{Only when \parlink{EParallelHatSpec} is non-zero
  and \parlink{RHSmode}==1 \\and \underscoreparlink{EParallelHatSpec\_bcdatFile}{EParallelHatSpec_bcdatFile}
  is not == ``''}
{When set this loads a file which looks like a bc file, but with the
  part which usually contains Fourier coefficients for
  $R$,$Z$,$B$,\ldots instead contains the coefficients for a function
  which will multiply the ``effective parallel electric fields'' \parlink{EParallelHatSpec}
  (otherwise just proportional to $B$).}
  
  \myhrule

\param{boozer\_bmnc}
{2D array of reals}
{0}
{Only when \parlink{geometryScheme} == 13. }
{Fourier harmonics describing the magnetic field in Boozer coordinates,
\begin{gather}
B(\theta_B,\zeta_B) = \sum_{m,n}\mathrm{\texttt{boozer\_bmnc}}(m,n) \cos(m\theta_B-n\mathrm{\texttt{Nperiods}} \zeta_B) + \mathrm{\texttt{boozer\_bmnc}}(m,n) \sin(m\theta_B-n\mathrm{\texttt{Nperiods}} \zeta_B),
\end{gather}
The first index of \texttt{ Boozer\_bmnc} corresponds to $m \in $[0,40], and the second corresponds to $n \in $[-40,40]. Here \parlink{Nperiods} can be specified in the input file.
}

\myhrule

\param{boozer\_bmns}
{2D array of reals}
{0}
{Only when \parlink{geometryScheme} == 13. }
{Fourier harmonics describing the magnetic field in Boozer coordinates,
\begin{gather}
B(\theta_B,\zeta_B) = \sum_{m,n}\mathrm{\texttt{boozer\_bmnc}}(m,n) \cos(m\theta_B-n\mathrm{\texttt{Nperiods}} \zeta_B) + \mathrm{\texttt{boozer\_bmnc}}(m,n) \sin(m\theta_B-n\mathrm{\texttt{Nperiods}} \zeta_B),
\end{gather}
The first index of \texttt{ Boozer\_bmns} corresponds to $m \in $[0,40], and the second corresponds to $n \in $[-40,40]. Here \parlink{Nperiods} can be specified in the input file.
}

\myhrule

\param{Nperiods}
{integer}
{0}
{Only when \parlink{geometryScheme} == 13.}
{Boozer geometry will assume number of periods is \texttt{Nperiods}.}

\myhrule


\section{The {\ttfamily speciesParameters}~namelist}

This namelist defines which species are included in the calculation, along with the density and temperature and gradients thereof.
You will definitely want to set the parameters in this namelist.
Note that only one of the four parameters 
\parlink{dnHatdpsiHats}, 
\parlink{dnHatdpsiNs}, 
\parlink{dnHatdrHats}, or
\parlink{dnHatdrNs}
will be used, depending on the value of \parlink{inputRadialCoordinateForGradients}
in the {\ttfamily \hyperref[sec:geometryParameters]{geometryParameters}} namelist.
Similarly, only one of the four parameters
\parlink{dTHatdpsiHats}, 
\parlink{dTHatdpsiNs}, 
\parlink{dTHatdrHats}, or
\parlink{dTHatdrNs}
will be used.

\myhrule

\param{Zs}
{1D array of reals}
{1.0}
{Always}
{Charges of each species, in units of the proton charge $e$}

\myhrule

\param{mHats}
{1D array of reals}
{1.0}
{Always}
{Masses of each species, in units of the reference mass $\bar{m}$}

\myhrule

\param{nHats}
{1D array of reals}
{1.0}
{Whenever \parlink{RHSMode} == 1}
{Densities of each species, in units of the reference density $\bar{n}$}

\myhrule

\param{THats}
{1D array of reals}
{1.0}
{Whenever \parlink{RHSMode} == 1}
{Temperatures of each species, in units of the reference temperature $\bar{T}$}

\myhrule

\param{dnHatdpsiHats}
{1D array of reals}
{0.0}
{Whenever \parlink{RHSMode} == 1 and \parlink{inputRadialCoordinateForGradients} == 0}
{Radial density gradients of each species, with respect to the radial coordinate $\hat{\psi}$, normalized by the reference density $\bar{n}$.}

\myhrule

\param{dTHatdpsiHats}
{1D array of reals}
{0.0}
{Whenever \parlink{RHSMode} == 1 and \parlink{inputRadialCoordinateForGradients} == 0}
{Radial temperature gradients of each species, with respect to the radial coordinate $\hat{\psi}$, normalized by the reference temperature $\bar{T}$.}

\myhrule

\param{dnHatdpsiNs}
{1D array of reals}
{0.0}
{Whenever \parlink{RHSMode} == 1 and \parlink{inputRadialCoordinateForGradients} == 1}
{Radial density gradients of each species, with respect to the radial coordinate $\psi_N$, normalized by the reference density $\bar{n}$.}

\myhrule

\param{dTHatdpsiNs}
{1D array of reals}
{0.0}
{Whenever \parlink{RHSMode} == 1 and \parlink{inputRadialCoordinateForGradients} == 1}
{Radial temperature gradients of each species, with respect to the radial coordinate $\psi_N$, normalized by the reference temperature $\bar{T}$.}

\myhrule

\param{dnHatdrHats}
{1D array of reals}
{0.0}
{Whenever \parlink{RHSMode} == 1 and \parlink{inputRadialCoordinateForGradients} == 2}
{Radial density gradients of each species, with respect to the radial coordinate $\hat{r}$, normalized by the reference density $\bar{n}$.}

\myhrule

\param{dTHatdrHats}
{1D array of reals}
{0.0}
{Whenever \parlink{RHSMode} == 1 and \parlink{inputRadialCoordinateForGradients} == 2}
{Radial temperature gradients of each species, with respect to the radial coordinate $\hat{r}$, normalized by the reference temperature $\bar{T}$.}

\myhrule

\param{dnHatdrNs}
{1D array of reals}
{0.0}
{Whenever \parlink{RHSMode} == 1 and \parlink{inputRadialCoordinateForGradients} == 3}
{Radial density gradients of each species, with respect to the radial coordinate $r_N$, normalized by the reference density $\bar{n}$.}

\myhrule

\param{dTHatdrNs}
{1D array of reals}
{0.0}
{Whenever \parlink{RHSMode} == 1 and \parlink{inputRadialCoordinateForGradients} == 3}
{Radial temperature gradients of each species, with respect to the radial coordinate $r_N$, normalized by the reference temperature $\bar{T}$.}

\myhrule

\param{withAdiabatic}
{Boolean}
{\false}
{Whenever \parlink{RHSMode} == 1 and \parlink{includePhi1} == \true and\\ \parlink{readExternalPhi1} == \false}
{If this parameter is \true, an adiabatic species is added into the quasineutrality equation (but has no other effect).}

\myhrule

\param{adiabaticZ}
{real}
{-1.0}
{Whenever \parlink{RHSMode} == 1 and \parlink{includePhi1} == \true and\\ \parlink{readExternalPhi1} == \false and \parlink{withAdiabatic} == \true}
{Charge of adiabatic species, in units of the proton charge $e$.}

\myhrule

\param{adiabaticMHat}
{real}
{5.44617e-4}
{Whenever \parlink{RHSMode} == 1 and \parlink{includePhi1} == \true and\\ \parlink{readExternalPhi1} == \false and \parlink{withAdiabatic} == \true}
{Mass of adiabatic species, in units of the reference mass $\bar{m}$.}

\myhrule

\param{adiabaticNHat}
{real}
{1.0}
{Whenever \parlink{RHSMode} == 1 and \parlink{includePhi1} == \true and\\ \parlink{readExternalPhi1} == \false and \parlink{withAdiabatic} == \true}
{Density of adiabatic species, in units of the reference density $\bar{n}$.}

\myhrule

\param{adiabaticTHat}
{real}
{1.0}
{Whenever \parlink{RHSMode} == 1 and \parlink{includePhi1} == \true and\\ \parlink{readExternalPhi1} == \false and \parlink{withAdiabatic} == \true}
{Temperature of adiabatic species, in units of the reference temperature $\bar{T}$.}

\myhrule

\param{withNBIspec} {Boolean} {\false} {Whenever \parlink{RHSMode} ==
  1 and \parlink{includePhi1} == \true and\\
  \parlink{readExternalPhi1} == \false and \parlink{quasineutralityOption} == 1} {When this is \true, an
  extra species (here called NBIspec) is added to the quasineutrality
  condition, but not as a species for which the DKE is solved. This is
  to mimic how the fast ions influence the other species via the
  $\phi_1$ variation on the flux surface. (The influence via
  collisions can be modelled using \parlink{EParallelHatSpec}). The
  NBIspec is assumed to have a density distribution on the flux suface
  proportional to $B$ (which is the case if all particles have zero
  pitch angle).}

\myhrule

\param{NBIspecZ}
{real}
{1.0}
{Whenever \parlink{withNBIspec}== \true and \parlink{RHSMode} == 1 and \parlink{includePhi1}\\
   == \true and \parlink{readExternalPhi1} == \false and \parlink{quasineutralityOption} == 1}
{Charge of the fast ion species, in units of the proton charge $e$, see \parlink{withNBIspec}.}

\myhrule

\param{NBIspecNHat}
{real}
{0.0}
{Whenever \parlink{withNBIspec}== \true and \parlink{RHSMode} == 1 and \parlink{includePhi1} \\
== \true and \parlink{readExternalPhi1} == \false and \parlink{quasineutralityOption} == 1}
{Density of the fast ion species, in units of the reference density
  $\bar{n}$, see \parlink{withNBIspec}. \todo{Implement possibility to load a bcdat file with the
  fast ion density distribution on the flux surfaces}}




\section{The {\ttfamily physicsParameters}~namelist}
\label{sec:physicsParameters}

The parameters in this namelist determine which terms are included or excluded in the kinetic equation.
You will want to be aware of most of these parameters.

\myhrule

\param{Delta}
{real}
{4.5694e-3}
{Whenever \parlink{RHSMode} == 1.}
{Roughly speaking, {\ttfamily Delta} is $\rho_*$ at the reference parameters. The precise definition is
\begin{eqnarray}
\mbox{\ttfamily Delta} 
&=& \frac{c \bar{m} \bar{v}}{e \bar{B} \bar{R}} \;\;\; \mbox{(Gaussian units)} \\
&=&  \frac{\bar{m} \bar{v}}{e \bar{B} \bar{R}} \;\;\; \mbox{(SI units)}, \nonumber
\end{eqnarray}
where $c$ is the speed of light,
$e$ is the proton mass,
and quantities with a bar are the normalization reference parameters discussed in section \ref{sec:normalizations}.
The default value {\ttfamily Delta} = 4.5694e-3 corresponds to $\bar{B}$ = 1 Tesla, $\bar{R}$ = 1 meter,
$\bar{m}$ = proton mass, and $\bar{T}$ = 1 keV.}

\myhrule

\param{alpha}
{real}
{1.0}
{Whenever \parlink{RHSMode} == 1 and $E_r$ is nonzero.}
{{\ttfamily alpha} $= e \bar{\Phi}/ \bar{T}$ (both Gaussian and SI units) where $e$ is the proton mass,
and $\bar{\Phi}$ and $\bar{T}$ are the normalization reference parameters discussed in section \ref{sec:normalizations}.
The default value {\ttfamily alpha} = 1.0 corresponds to $\bar{T}$ = 1 keV and $\bar{\Phi}$ = 1 kV.
The default value {\ttfamily alpha} = 1.0 also corresponds to $\bar{T}$ = 1 eV and $\bar{\Phi}$ = 1 V.
}

\myhrule

%\param{nu\_n}
\paramWithUnderscore{nu\_n}
{nu_n}
{real}
{8.330e-3}
{Whenever \parlink{RHSMode} == 1}
{Dimensionless collisionality at the reference parameters:
\begin{equation}
\mbox{\ttfamily nu\_n} = \bar{\nu} \frac{\bar{R}}{\bar{v}},
\end{equation}
where $\bar{R}$ and $\bar{v}$ are the normalization reference parameters discussed in section \ref{sec:normalizations},
and $\bar{\nu}$ is the dimensional collision frequency at the reference parameters. This frequency is defined as
\begin{eqnarray}
\bar{\nu}
&=& \frac{4\sqrt{2\pi} \bar{n} e^4 \ln\Lambda}{3 (4\pi\epsilon_0)^2 \sqrt{\bar{m}} \bar{T}^{3/2}} \;\;\; \mbox{(SI units}) \\
&=& \frac{4\sqrt{2\pi} \bar{n} e^4 \ln\Lambda}{3 \sqrt{\bar{m}} \bar{T}^{3/2}} \;\;\; \mbox{(Gaussian units}) \nonumber
\end{eqnarray}
where $e$ is the proton charge, $\bar{n}$, $\bar{m}$, and $\bar{T}$ are the normalization reference parameters discussed in section \ref{sec:normalizations},
and $\ln\Lambda$ is the Coulomb logarithm.
The default value {\ttfamily nu\_n} = 8.330e-3 corresponds to $\bar{R}$ = 1 meter,
$\bar{m}$ = proton mass, $\bar{n}$ = $10^{20}$ m$^{-3}$, $\bar{T}$ = 1 keV, and $\ln\Lambda = 17$.
If $\text{\ttfamily nu\_n} < 0$ in {\ttfamily input.namelist} then {\ttfamily nu\_n} will be calculated automatically using the density and temperature of the first species with the assumption that it is electrons, and assuming $\bar{R}$ = 1 meter, $\bar{m}$ = proton mass, $\bar{n}$ = $10^{20}$ m$^{-3}$, $\bar{T}$ = 1 keV. 
}

\myhrule

\param{nuPrime}
{real}
{1.0}
{Only when \parlink{RHSMode} == 3.}
{Dimensionless collisionality used in place of \parlink{nHats}, \parlink{THats}, \parlink{mHats}, \parlink{Zs}, and \underscoreparlink{nu\_n}{nu_n} for computing monoenergetic transport coefficients.
See section \ref{sec:monoenergetic} for more details.}

\myhrule

\param{EStar}
{real}
{0.0}
{Only when \parlink{RHSMode} == 3.}
{Normalized radial electric field used in place of {\ttfamily dPhiHatdXXX} for computing monoenergetic transport coefficients.
See section \ref{sec:monoenergetic} for more details.}

\myhrule

\param{EParallelHat}
{real}
{0.0}
{Whenever \parlink{RHSMode} == 1}
{Inductive parallel electric field:
\begin{equation}
\mbox{\ttfamily EParallelHat} = \left< \vect{E}\cdot\vect{B}\right> \frac{\bar{R}}{\bar{\Phi}\bar{B}}
\end{equation}
(in both Gaussian and SI units) where $\left< \ldots \right>$ denotes a flux surface average,
$\vect{E}$ and $\vect{B}$ are the electric and magnetic field vectors, and 
quantities with a bar are the normalization reference parameters discussed in section \ref{sec:normalizations}.}

\myhrule

\param{dPhiHatdpsiHat}
{real}
{0.0}
{Whenever \parlink{RHSMode} == 1 and \parlink{inputRadialCoordinateForGradients} == 0}
{The derivative of the electrostatic potential with respect to the radial coordinate $\hat{\psi}$,
i.e. the radial electric field up to a constant.
Notice that exactly 1 of the 5 variables \parlink{dPhiHatdpsiHat}, \parlink{dPhiHatdpsiN}, \parlink{dPhiHatdrHat}, \parlink{dPhiHatdrN}, or \parlink{Er}
will be used, depending on\\
\parlink{inputRadialCoordinateForGradients}.
}

\myhrule

\param{dPhiHatdpsiN}
{real}
{0.0}
{Whenever \parlink{RHSMode} == 1 and \parlink{inputRadialCoordinateForGradients} == 1}
{The derivative of the electrostatic potential with respect to the radial coordinate $\psi_N$,
i.e. the radial electric field up to a constant.
Notice that exactly 1 of the 5 variables \parlink{dPhiHatdpsiHat}, \parlink{dPhiHatdpsiN}, \parlink{dPhiHatdrHat}, \parlink{dPhiHatdrN}, or \parlink{Er}
will be used, depending on\\
\parlink{inputRadialCoordinateForGradients}.
}

\myhrule

\param{dPhiHatdrHat}
{real}
{0.0}
{Whenever \parlink{RHSMode} == 1 and \parlink{inputRadialCoordinateForGradients} == 2}
{The derivative of the electrostatic potential with respect to the radial coordinate $\hat{r}$,
i.e. the radial electric field up to a constant.
Notice that exactly 1 of the 5 variables \parlink{dPhiHatdpsiHat}, \parlink{dPhiHatdpsiN}, \parlink{dPhiHatdrHat}, \parlink{dPhiHatdrN}, or \parlink{Er}
will be used, depending on\\
\parlink{inputRadialCoordinateForGradients}.
}

\myhrule

\param{dPhiHatdrN}
{real}
{0.0}
{Whenever \parlink{RHSMode} == 1 and \parlink{inputRadialCoordinateForGradients} == 3}
{The derivative of the electrostatic potential with respect to the radial coordinate $r_N$,
i.e. the radial electric field up to a constant.
Notice that exactly 1 of the 5 variables \parlink{dPhiHatdpsiHat}, \parlink{dPhiHatdpsiN}, \parlink{dPhiHatdrHat}, \parlink{dPhiHatdrN}, or \parlink{Er}
will be used, depending on\\
\parlink{inputRadialCoordinateForGradients}.
}


\myhrule

\param{Er}
{real}
{0.0}
{Whenever \parlink{RHSMode} == 1 and \parlink{inputRadialCoordinateForGradients} == 4}
{The derivative of the normalized electrostatic potential $\hat{\Phi}$ with respect to the radial coordinate $\hat{r}$, multiplied by $-1$,
i.e. {\ttfamily Er}$=-$\parlink{dPhiHatdrHat}.
Notice that exactly 1 of the 5 variables \parlink{dPhiHatdpsiHat}, \parlink{dPhiHatdpsiN}, \parlink{dPhiHatdrHat}, \parlink{dPhiHatdrN}, or \parlink{Er}
will be used, depending on\\
\parlink{inputRadialCoordinateForGradients}.
}

\myhrule

\param{collisionOperator}
{integer}
{0}
{Always}
{Which collision operator to use:\\

{\setlength{\parindent}{0cm}

{\ttfamily collisionOperator} = 0: Full linearized Fokker-Planck operator.\\

{\ttfamily collisionOperator} = 1: Pitch-angle scattering operator (with no momentum-conserving field term).
}\newline
\newline
See section~\ref{sec:CollisionOperator} for more details about the collision operator.}

\myhrule

\param{constraintScheme}
{integer}
{-1}
{Always}
{Controls a small number of extra rows and columns of the system matrix
which (1) eliminate the null space of the matrix, and (2) ensure that a steady-state solution
to the kinetic equation exists even when phase-space volume and/or energy are not conserved.
These issues are detailed in section III of Ref \cite{sfincsPaper}.
\\

{\setlength{\parindent}{0cm}

{\ttfamily constraintScheme} = -1: Automatic. If \parlink{collisionOperator}==0 then {\ttfamily constraintScheme} will be set to 1, 
otherwise {\ttfamily constraintScheme} will be set to 2.\\

{\ttfamily constraintScheme} = 0: No constraints.\\

{\ttfamily constraintScheme} = 1: 2 constraints per species: $\left<n_1\right>=0$ and $\left<p_1\right>=0$.
The particle and heat sources have the form $S = (a_2 x^2 + a_0) e^{-x^2}$.
The $a_2$ and $a_0$ coefficients are determined so that one source term provides particles but not energy,
whereas the other source term provides energy but not particles. \\

{\ttfamily constraintScheme} = 2: \Nx~constraints per species: $\left< f(L=0)\right>=0$ at each $x$.\\

{\ttfamily constraintScheme} = 3: Same as {\ttfamily constraintScheme} = 1,
except the particle and heat sources have the form $S = (a_4 x^4 + a_0) e^{-x^2}$.\\

{\ttfamily constraintScheme} = 4: Same as {\ttfamily constraintScheme} = 1,
except the particle and heat sources have the form $S = (a_4 x^4 + a_2 x^2) e^{-x^2}$.\\

You should set {\ttfamily constraintScheme} to -1 unless you know what you are doing.
}}

\myhrule

\param{includeXDotTerm}
{Boolean}
{\true}
{Whenever \parlink{RHSMode} $<3$ and the radial electric field is nonzero.}
{Whether or not to include the term in the kinetic equation corresponding to a change
in speed proportional to the radial electric field.  This term is given by $\dot{x}$ in
equation (17) of \cite{sfincsPaper}:}
\begin{equation}
-(\vect{v}_{ma} \cdot\nabla r) \frac{Z_s e}{2 T_s x_s} \frac{d\Phi_0}{dr} \frac{\partial f_{a1}}{\partial x_s}
\end{equation}
\myhrule

\param{includeElectricFieldTermInXiDot}
{Boolean}
{\true}
{Whenever \parlink{RHSMode} $<3$ and the radial electric field is nonzero.}
{Whether or not to include the term in the kinetic equation corresponding to a change
in pitch angle $\xi$ proportional to the radial electric field.  This term is given by the last line of
equation (17) of \cite{sfincsPaper}:}
\begin{equation}
\frac{(1-\xi^2)\xi}{2B^3} \frac{d\Phi_0}{dr}(\vect{B}\times\nabla r\cdot\nabla B)
 \frac{\partial f_{s1}}{\partial \xi}
\end{equation}

\myhrule

\param{useDKESExBDrift}
{Boolean}
{\false}
{Whenever \parlink{RHSMode} $<3$ and the radial electric field is nonzero.}
{If true, the $\vect{E}\times\vect{B}$ drift term 
multiplying $\partial f/\partial \theta$ and  $\partial f/\partial \zeta$
is taken to be $\vect{E}\times\vect{B}\cdot \nabla (\theta \;\mbox{or} \;\zeta) / \left< B^2 \right>$
instead of 
 $\vect{E}\times\vect{B}\cdot \nabla (\theta \;\mbox{or} \;\zeta) /B^2$.
}

\myhrule

\paramWithUnderscore{include\_fDivVE\_term}{include_fDivVE_term}
{Boolean}
{\false}
{Never}
{Obsolete}

\myhrule

\param{includePhi1}
{Boolean}
{\false}
{Whenever \parlink{RHSMode} == 1.}
{If false, no terms involving $\Phi_1 = \Phi-\left<\Phi\right>$ are included in the kinetic equation,
and the quasineutrality equation is not solved.  

If true, and \parlink{readExternalPhi1} == \false, then terms involving $\Phi_1$ are included
in the kinetic equation if \parlink{includePhi1InKineticEquation} = \true, and the quasineutrality equation is solved at each point on the flux surface 
(make sure that your input densities fulfill quasineutrality, see \parlink{quasineutralityOption}) together with the condition $\left<\Phi_1\right> = 0$. 
In this latter case, the system becomes nonlinear in the unknowns $f_{s1}$ and $\Phi_1$. 
Newton's method will be used to solve the nonlinear system, meaning that the usual linear solve in \sfincs~must be iterated several times. 

If true, and \parlink{readExternalPhi1} == \true, then $\Phi_1$ is read from an input file (given by \parlink{externalPhi1Filename}), 
the quasineutrality equation and the condition $\left<\Phi_1\right> = 0$ are ignored and the system is linear.\newline 

If true, many more quantities are computed and saved in the output file, such as radial fluxes
associated with the radial $\vect{E}\times\vect{B}$ drift caused by $\Phi_1$ (see section~\ref{sec:RadialFluxesAndFlows}).
More details on runs including $\Phi_1$ are found in section~\ref{sec:qn}.
}

\myhrule

\param{readExternalPhi1}
{Boolean}
{\false}
{Whenever \parlink{RHSMode} == 1 and \parlink{includePhi1} == \true}
{If true, \parlink{Phi1Hat} is read from the HDF5 file specified by \parlink{externalPhi1Filename}, 
the quasineutrality equation and the condition $\left<\Phi_1\right> = 0$ are ignored and the solved system is linear.
If true, and \parlink{includePhi1InKineticEquation} = \false, then $\Phi_1$ does not appear anywhere in the system of equations, 
and $f_{s1}$ is unaffected by $\Phi_1$. 
However, the fluxes are still affected by $\Phi_1$ (see section~\ref{sec:RadialFluxesAndFlows}).
}

\myhrule

\param{externalPhi1Filename}
{string}
{``externalPhi1.h5''}
{Whenever \parlink{RHSMode} == 1 and \parlink{includePhi1} == \true and\\ \parlink{readExternalPhi1} == \true}
{Name of the HDF5 file from which \parlink{Phi1Hat} is read. The HDF5 file must contain the following fields specified in the same format as in the output file (\parlink{outputFileName}):
\parlink{Ntheta}, \parlink{Nzeta}, \parlink{NIterations}, \parlink{NPeriods}, \parlink{theta}, \parlink{zeta}, \parlink{Phi1Hat}. 
It is assumed that \parlink{theta} and \parlink{zeta} represent a 2D uniform grid on which \parlink{Phi1Hat} is given, but this grid can be different from the grid used in the calculation (i.e. \parlink{Ntheta}, \parlink{Nzeta} in the external HDF5 file do not have to be the same as specified in {\ttfamily input.namelist}). Linear interpolation is used to determine \parlink{Phi1Hat} in the calculation.}

\myhrule

\param{includePhi1InKineticEquation}
{Boolean}
{\true}
{Whenever \parlink{RHSMode} == 1 and \parlink{includePhi1} == \true}
{If true, the terms containing $\Phi_1$ will be included in the kinetic equation. 
If false, \parlink{includePhi1} == \true and \parlink{readExternalPhi1} == \false, then $\Phi_1$ is only included in the quasineutrality equation. 
}

\myhrule

\param{includePhi1InCollisionOperator}
{Boolean}
{\false}
{Whenever \parlink{RHSMode} == 1 and \parlink{includePhi1} == \true and\\ \parlink{includePhi1InKineticEquation} == \true}
{If true, the terms containing $\Phi_1$ will be included in the collision operator. 
If false (or \parlink{includePhi1InKineticEquation} == \false) %, or \parlink{includePhi1} == \false, 
then $\Phi_1$ is not included in the collision operator. 
The default is false since this setting has yet only had a minor impact on the results, and the memory and time requirements can increase significantly when it is true.
\newline \warning{Setting this to true is not yet compatible with \parlink{readExternalPhi1} == \true}
}

\myhrule

\param{quasineutralityOption}
{integer}
{1}
{Whenever \parlink{RHSMode} == 1 and \parlink{includePhi1} == \true and\\ \parlink{readExternalPhi1} == \false}
{This variable controls which quasineutrality equation is used, and must be set to either 1 or 2. 
If including $\Phi_1$ and not reading it from an external file (\parlink{readExternalPhi1} == \true), then make sure that your input densities fulfill quasineutrality (also accounting for the adiabatic species if \parlink{withAdiabatic}=\true).\\

{\ttfamily quasineutralityOption} = 1: Full quasineutrality equation. All species (kinetic and adiabatic if applicable) are included in the quasineutrality equation.\\

{\ttfamily quasineutralityOption} = 2: {\ttfamily EUTERPE} quasineutrality. \sfincs~must be run with an adiabatic species, \parlink{withAdiabatic}=\true, and only the adiabatic species and the first kinetic species are included in the quasineutrality equation (their input densities must fulfill quasineutrality). This is the quasineutrality considered in Ref \cite{Regana2017}.
}


%%The includeRadialExBDrive parameter has been removed by AM 2016-07
%\myhrule
%
%\param{includeRadialExBDrive}
%{Boolean}
%{\false}
%{Whenever \parlink{RHSMode} == 1.}
%{If true, the radial $\vect{E}\times\vect{B}$ term $(\vect{v}_{E} \cdot\nabla\psi)f_{Ms} [(1/n_s)(dn_s/d\psi) + (x_s^2-3/2)(1/T_s)(dT_s/d\psi)]$
%will be included in the kinetic equation. This is one of the terms considered in Ref \cite{Regana2013} which
%should be unimportant for the main ions but which may be important for impurities.
%Use of this option requires \parlink{includePhi1}=\true, since the radial $\vect{E}\times\vect{B}$ drift
%arises due to $\Phi_1$.
%}

%%The nonlinear parameter has been removed by AM 2016-07
%\myhrule
%
%\param{nonlinear}
%{Boolean}
%{\false}
%{Whenever \parlink{RHSMode} == 1.}
%{If true, the term
%$-(Z_s e/m) (\nabla_{||} \Phi_1) (\partial f_{s1}/\partial v_{||})_\mu$ will be included
%in the kinetic equation.  This is one of the terms considered in Ref \cite{Regana2013} which
%should be unimportant for the main ions but which may be important for impurities.
%This term is nonlinear in the unknowns $f_{s1}$ and $\Phi_1$.
%Newton's method will be used to solve the nonlinear system, meaning that the usual linear solve in \sfincs~must
%be iterated several times.
%Running with {\ttfamily nonlinear}=\true requires \parlink{includePhi1}=\true
%}

\myhrule

\param{includeTemperatureEquilibrationTerm}
{Boolean}
{\false}
{Whenever \parlink{RHSMode} == 1.}
{When true, the term $C_{ab}[ f_{aM}, f_{bM}]$ is included in the kinetic equation,
i.e. collisions between the leading-order Maxwellians of different species.  This term is nonzero
when the temperature is not the same for all species.  The resulting contribution to the non-Maxwellian
distribution function is isotropic and so does not directly give any parallel or radial transport.}

\myhrule

\param{magneticDriftScheme}
{integer}
{0}
{Whenever \parlink{RHSMode} == 1.}
{This variable controls the poloidal and toroidal magnetic drifts, and does not affect the radial magnetic drift.\\
\warning{Some terms involving both $\Phi_1$ and the magnetic drifts have not yet been implemented, 
and therefore using another setting than 0 is incompatible with \parlink{includePhi1} == \true. 
However, for testing purposes it is still allowed to use a non-zero setting together with \parlink{includePhi1} == \true, 
but the results may not be physical.}\\

{\ttfamily magneticDriftScheme} = 0: No poloidal or toroidal magnetic drift.\\

{\ttfamily magneticDriftScheme} = 1: Use the magnetic drift $v_m = (v_{||} / \Omega_c) \nabla \times (v_{||} \vect{b})$.\\

{\ttfamily magneticDriftScheme} = 2: Use the grad-B and curvature
drift, plus the parallel velocity correction $v_{\perp}^2/(2 \Omega_c)
\vect{b} \vect{b} \cdot \nabla \times \vect{b}$.\\

{\ttfamily magneticDriftScheme} = 3: Magnetic drift as defined in
Eq.~(67) in \cite{Kasilov2014}.\\

{\ttfamily magneticDriftScheme} = 4: Magnetic drift as defined in
Eq.~(16) in \cite{Martitsch2016}.\\ (This {\ttfamily
  magneticDriftScheme} only works for .bc magnetic
geometry input files so far)\\

{\ttfamily magneticDriftScheme} = 5: Magnetic drift as defined in
Eqs.~(46--48) in \cite{Sugama2016}. The function $\alpha$
 is chosen as $\alpha=(1-\xi^2)/(1+\xi^2)$ for the terms
in Eq.~(48) proportional to the normal curvature, which are the terms
that need
to be regularized at $\xi=\pm 1$.\\

{\ttfamily magneticDriftScheme} = 6: Same as {\ttfamily magneticDriftScheme} 5,
except that no regularization is applied to the magnetic drift terms multiplying $\partial f/\partial \theta$
and $\partial f/\partial\zeta$. Regularization is still applied to the magnetic drift term multiplying $\partial f/\partial \xi$.\\

{\ttfamily magneticDriftScheme} = 7: Same as {\ttfamily magneticDriftScheme} 1,
except the contribution to $\dot{\xi}$ from the magnetic drifts is dropped.\\

{\ttfamily magneticDriftScheme} = 8: Same as {\ttfamily magneticDriftScheme} 1,
except the magnetic shear term for axisymmetry is added to the coefficient of $\partial f/\partial \zeta$.
There is no change to the coefficient of $\partial f/\partial\theta.$ This option only makes sense for straight field line coordinates
and nearly axisymmetric geometry.\\

{\ttfamily magneticDriftScheme} = 9: Same as {\ttfamily magneticDriftScheme} 1,
except the magnetic shear term for axisymmetry is added to the coefficient of $\partial f/\partial \theta$.
There is no change to the coefficient of $\partial f/\partial\zeta.$ This option only makes sense for straight field line coordinates
and nearly axisymmetric geometry.\\


}

\myhrule

\param{EParallelHatSpec}
{1D array of reals}
{0.0}
{Whenever it is set to non-zero and \parlink{RHSmode}==1}
{This is used to introduce parallel forces due to collisions with
  a fast ion species (which are not included in the DKE solve). The
  collision operator for collisions with a fast species has the same
  structure as parallel electric field term in the DKE, and the input parameter
  here is thus given in terms of a corresponding ``effective'' electric field. Since the
forces from these collisions are different on the different species,
this input must be given as an array of values corresponding to the different
species. These effective electric fields are added to the physical one
\parlink{EParallelHat} in the code. The electric field strength is
proportional to $B$ unless explicitly specified using an input file \underscoreparlink{EParallelHatSpec\_bcdatFile}{EParallelHatSpec_bcdatFile}.}








\section{The {\ttfamily resolutionParameters}~namelist}
\label{sec:resolutionParameters}

In this namelist, there are 4 parameters you definitely need to be aware of and adjust: \Ntheta, \Nzeta, \Nxi, and \Nx.  
See chapter \ref{ch:resolution} for details. You may or may not
need to adjust {\ttfamily solverTolerance}.  The other parameters in this namelist almost never need to be adjusted.

\myhrule

\param{Ntheta}
{integer}
{15}
{Always}
{Number of grid points in the poloidal angle. 
This parameter should be odd; see \parlink{forceOddNthetaAndNzeta} in this namelist.
Memory and time requirements DO depend strongly on this parameter.
For stellarator calculations, this parameter can usually be in the range 15-25.
For tokamak calculations at low collisionality, the value of this parameter may need to be higher.}


\myhrule

\param{Nzeta}
{integer}
{15}
{Always}
{Number of grid points in the toroidal angle (per identical segment of the stellarator.)  
This parameter should be odd; see \parlink{forceOddNthetaAndNzeta} in this namelist.
Memory and time requirements DO depend strongly on this parameter.
Set this parameter to 1 for a tokamak calculation.
For stellarator calculations, the value of this parameter required for convergence depends strongly on
the collisionality. At high collisionality, this parameter can be several 10s, depending
on the complexity of $B(\theta,\zeta)$. At low collisionality, this parameter may need to be many 10s or
even $>$ 100 for convergence.
}

\myhrule

\param{Nxi}
{integer}
{16}
{Always}
{Number of Legendre polynomials used to represent the pitch-angle dependence of the distribution function.
Memory and time requirements DO depend strongly on this parameter.
The value of this parameter required for convergence depends strongly on
the collisionality. At high collisionality, this parameter can be as low
as 5. At low collisionality, this parameter may need to be many 10s or
even $>$ 100 for convergence.}

\myhrule

\param{Nx}
{integer}
{5}
{Always}
{Number of grid points in energy used to represent the distribution function.
Memory and time requirements DO depend strongly on this parameter.
This parameter almost always needs to be at least 5.
Usually a value in the range 5-8 is plenty for convergence, though in exceptional circumstances
you may need to go up to 10-15.
}

\myhrule

\param{solverTolerance}
{real}
{1e-6}
{Whenever \parlink{useIterativeLinearSolver} == \true}
{
Tolerance used to define convergence of the Krylov solver.
This parameter does not affect memory requirements but it does affect the
time required for solution somewhat.
Occasionally you may want to ease this tolerance to 1e-5 so fewer iterations of the Krylov solver are needed.
}

\myhrule

\param{NL}
{integer}
{4}
{Whenever \parlink{collisionOperator} == 0.}
{Number of Legendre polynomials used to represent the Rosenbluth
potentials. This number can basically always be 4,
since results barely change when \parlink{NL} is increased above this value.
Memory and time requirements do NOT depend strongly on this parameter.
}

\myhrule

\param{NxPotentialsPerVth}
{real}
{40.0}
{Only when \parlink{collisionOperator} == 0 and \parlink{xGridScheme} $<$ 5.
Since \parlink{xGridScheme} = 5 is recommended, this parameter is basically obsolete.}
{
Number of grid points in energy used to represent the Rosenbluth potentials
for the original implementation of the Fokker-Planck operator described in \cite{speedGrids}.
Memory and time requirements do NOT depend strongly on this parameter.}

\myhrule

\param{xMax}
{real}
{5.0}
{Only when \parlink{collisionOperator} == 0 and \parlink{xGridScheme} $<$ 5.
Since \parlink{xGridScheme} = 5 is recommended, this parameter is basically obsolete.}
{
Maximum normalized speed for the Rosenbluth potential grid
for the original implementation of the Fokker-Planck operator described in \cite{speedGrids}.
Memory and time requirements do NOT depend strongly on this parameter.}

\myhrule

\param{forceOddNthetaAndNzeta}
{Boolean}
{\true}
{Always}
{
If true, 1 is added to \Ntheta~any time a run is attempted with even \Ntheta,
and 1 is added to \Nzeta~any time a run is attempted with even \Nzeta.
When false, the even and odd grid points are effectively decoupled so results are unstable.
This parameter should be true unless you know what you are doing.
}














\section{The {\ttfamily otherNumericalParameters}~namelist}
\label{sec:otherNumericalParameters}

The parameters in this namelist are advanced, and the default values are best for routine use of the code.

\myhrule

\param{thetaDerivativeScheme}
{integer}
{2}
{Always}
{Discretization scheme for the poloidal angle coordinate theta.\\

{\ttfamily thetaDerivativeScheme} = 0: Fourier spectral collocation.  The differentiation matrix in theta is dense.\\

{\ttfamily thetaDerivativeScheme} = 1: Finite differences with a 3 point stencil.  (The differentiation matrix in theta is tridiagonal, aside from the corners.)\\

{\ttfamily thetaDerivativeScheme} = 2: Finite differences with a 5 point stencil.  (The differentiation matrix in theta is pendadiagonal, aside from the corners.).\\

The best value for this parameter is usually 2.}


\myhrule

\param{zetaDerivativeScheme}
{integer}
{2}
{Always}
{Discretization scheme for the toroidal angle coordinate zeta.\\

{\ttfamily zetaDerivativeScheme} = 0: Fourier spectral collocation.  The differentiation matrix in zeta is dense.\\

{\ttfamily zetaDerivativeScheme} = 1: Finite differences with a 3 point stencil.  (The differentiation matrix in zeta is tridiagonal, aside from the corners.)\\

{\ttfamily zetaDerivativeScheme} = 2: Finite differences with a 5 point stencil.  (The differentiation matrix in zeta is pendadiagonal, aside from the corners.).\\

The best value for this parameter is usually 2.}

\myhrule

\param{ExBDerivativeSchemeTheta}
{integer}
{0}
{Whenever the radial electric field is nonzero}
{Options for controlling upwinding of the $\vect{E}\times\vect{B}$ drift terms.  Note the options are different than for \parlink{thetaDerivativeScheme}
and \parlink{zetaDerivativeScheme}, and are analogous to the options for \parlink{magneticDriftDerivativeScheme}.
This option exists because when the radial electric field is large enough to be comparable to the resonance,
such that the coefficient in front of the $\partial f/\partial \theta$ or $\partial f/\partial\zeta$ terms vanishes near the thermal speed of one of the species,
the distribution function can develop unphysical grid-scale structure.  This option allows upwinding of the $\partial f/\partial\theta$
spatial derivative, which eliminates the grid-scale oscillations.
The parameter \parlink{ExBDerivativeSchemeZeta} serves the same function for the $\partial f/\partial\zeta$ derivative.
\\

{\ttfamily ExBDerivativeSchemeTheta} = 0: Use same differentiation matrices for the $\vect{E}\times\vect{B}$ drift terms as for the parallel streaming term.\\

{\ttfamily ExBDerivativeSchemeTheta} = 1: Treat the $\vect{E}\times\vect{B}$ drift terms using a 4 point upwinded stencil (1 point on 1 side, 2 points on the other.)\\

{\ttfamily ExBDerivativeSchemeTheta} = 2: Treat the $\vect{E}\times\vect{B}$ drift terms using a 5 point upwinded stencil (1 point on 1 side, 3 points on the other.)\\

{\ttfamily ExBDerivativeSchemeTheta} = 3: Treat the $\vect{E}\times\vect{B}$ drift terms using a 6 point upwinded stencil (2 points on 1 side, 3 points on the other.)\\

The different settings require slightly different amounts of memory for factorization due to the different numbers of nonzeros. Option 1 requires the least memory, then 0, then 2,
and 3 requires the most.  The difference in memory required appears to be small, around 10-20\% between settings 1 and 3.
On the other hand, the denser the stencil, the more accurate the result. Hence, in order from least to most accurate, the options are 1, 0, 2, 3.
Option 1 is substantially less accurate than the other options.
You should use the default {\ttfamily ExBDerivativeSchemeTheta} = 0 except for very large radial electric fields, when the electric field is as large as the resonance or larger.
In this case, {\ttfamily ExBDerivativeSchemeTheta} = 3 is recommended.
}

\myhrule

\param{ExBDerivativeSchemeZeta}
{integer}
{0}
{Whenever the radial electric field is nonzero}
{This parameter behaves exactly like \parlink{ExBDerivativeSchemeTheta}, except it applies to the $\zeta$ coordinate instead of $\theta$.}

\myhrule

\param{magneticDriftDerivativeScheme}
{integer}
{3}
{Whenever \parlink{magneticDriftScheme} is nonzero}
{Options for controlling upwinding of the magnetic drift terms.  Note the options are different than for \parlink{thetaDerivativeScheme}
and \parlink{zetaDerivativeScheme}, and are analogous to the options for \parlink{ExBDerivativeSchemeTheta}.
This option exists because when magnetic drift terms involving $\partial f/\partial \theta$ and $\partial f/\partial\zeta$
are implemented using the same centered difference stencil as the parallel streaming term,
the distribution function can develop unphysical grid-scale structure.  This option allows upwinding of these spatial derivatives, which eliminates the grid-scale oscillations.\\

{\ttfamily magneticDriftDerivativeScheme} = 0: Use same differentiation matrices for the magnetic drift terms as for the parallel streaming term.\\

{\ttfamily magneticDriftDerivativeScheme} = 1: Treat the magnetic drift terms using a 4 point upwinded stencil (1 point on 1 side, 2 points on the other.)\\

{\ttfamily magneticDriftDerivativeScheme} = 2: Treat the magnetic drift terms using a 5 point upwinded stencil (1 point on 1 side, 3 points on the other.)\\

{\ttfamily magneticDriftDerivativeScheme} = 3: Treat the magnetic drift terms using a 6 point upwinded stencil (2 points on 1 side, 3 points on the other.)\\

The different settings require slightly different amounts of memory for factorization due to the different numbers of nonzeros. Option 1 requires the least memory, then 0, then 2,
and 3 requires the most.  The difference in memory required appears to be small, around 10-20\% between settings 1 and 3.
On the other hand, the denser the stencil, the more accurate the result. 
Hence, in order from least to most accurate, the options are 1, 0, 2, 3. Option 1 is substantially less accurate than the other options.
The default setting of 3 is robust and recommended in most cases.
}

\myhrule

\param{xGridScheme}
{integer}
{5}
{Whenever \parlink{RHSMode} is 1 or 2.}
{Discretization scheme for the speed coordinate $x$.\\

{\ttfamily xGridScheme} = 1: New orthogonal polynomials with no point at $x=0$. Original treatment of Rosenbluth potentials.\\

{\ttfamily xGridScheme} = 2: New orthogonal polynomials with a point at $x=0$. Original treatment of Rosenbluth potentials.\\

{\ttfamily xGridScheme} = 3: Uniform finite differences on [0, \parlink{xMax}], forcing $f=0$ at \parlink{xMax}. 2-point stencil for interpolating to other grids.\\

{\ttfamily xGridScheme} = 4: Uniform finite differences on [0, \parlink{xMax}], forcing $f=0$ at \parlink{xMax}. 4-point stencil for interpolating to other grids.\\

{\ttfamily xGridScheme} = 5: New orthogonal polynomials with no point at $x=0$. New treatment of Rosenbluth potentials.\\

{\ttfamily xGridScheme} = 6: New orthogonal polynomials with a point at $x=0$. New treatment of Rosenbluth potentials.\\

{\ttfamily xGridScheme} = 7: Chebyshev grid on [0, \parlink{xMax}], forcing $f=0$ at \parlink{xMax}. Original treatment of Rosenbluth potentials.\\

{\ttfamily xGridScheme} = 8: Chebyshev grid on [0, \parlink{xMax}], with no boundary condition imposed at \parlink{xMax}. Original treatment of Rosenbluth potentials.\\

The recommended value for this parameter is the default, 5.  
When {\ttfamily xGridScheme} = 5 or 6, then the following quantities do not matter: 
\parlink{NxPotentialsPerVth}, \parlink{xMax}, and \parlink{xPotentialsGridScheme}.}

\myhrule

\paramWithUnderscore{xGrid\_k}{xGrid_k}
{integer}
{0}
{Whenever \parlink{RHSMode} is 1 or 2 and \parlink{xGridScheme} = 1, 2, 5, or 6.}
{For \parlink{xGridScheme} = 1, 2, 5, or 6, the distribution function will be represented in terms of polynomials $P_n(x)$
that are orthogonal under the weight $\int_0^\infty dx\; x^k \exp(-x^2) P_n(x) P_m(x)  \propto  \delta_{n,m}$
where $k$ is an exponent set by the parameter {\ttfamily xGrid\_k} here.
A good value to use is 0, 1, or 2.}

\myhrule

\param{xPotentialsGridScheme}
{integer}
{2}
{Whenever \parlink{RHSMode} is 1 or 2 and \parlink{xGridScheme} is $<$5.
Since the recommended setting for \parlink{xGridScheme} is 5, this parameter is rarely relevant.}
{When an explicit grid is used for the Rosenbluth potentials, which grid and interpolation scheme to use.\\

{\ttfamily xPotentialsGridScheme} = 1: Uniform grid. 5-point stencil for derivatives. 2-point stencil for interpolating to other grids.\\

{\ttfamily xPotentialsGridScheme} = 2: Uniform grid. 5-point stencil for derivatives. 4-point stencil for interpolating to other grids.\\

{\ttfamily xPotentialsGridScheme} = 3: Use same grid as for distribution function, so no interpolation needed for the self-collision operator.
  You must set \parlink{xGridScheme} = 3 or 4 to use this setting.  Use 2-point stencil for interpolating to other species' grids.\\

{\ttfamily xPotentialsGridScheme} = 4: Same as option 3, except use a 4-point stencil for interpolating to other species' grids.\\

The recommended setting is {\ttfamily xPotentialsGridScheme} = 2.}

\myhrule

\param{xDotDerivativeScheme}
{integer}
{0}
{Whenever \parlink{includeXDotTerm} is \true.}
{Changes the differentiation matrix used for the collisionless $\dot{x} \propto E_r$ term. This parameter
does not affect the differentiation matrix used for the energy scattering part of the collision operator.\\

{\ttfamily xDotDerivativeScheme} = 0: Use the same differentiation matrix for the $\dot{x}$ term as for the collision operator.\\

{\ttfamily xDotDerivativeScheme} = 11: Use a low-order tri-diagonal differentiation matrix for the $\dot{x}$ term.\\

Other values of {\ttfamily xDotDerivativeScheme} have been implemented (see {\ttfamily createGrids.F90}) but are
not recommended. The recommended setting is almost always {\ttfamily xDotDerivativeScheme} = 0.
The one exception is sometimes when \parlink{magneticDriftScheme}$>0$, in which
case the convergence with respect to \parlink{Nx} is sometimes poor for values of $E_r$ near the peak in the radial fluxes.
In this case, {\ttfamily xDotDerivativeScheme} = 11 may resolve the problem.
}

\myhrule

\param{useIterativeLinearSolver}
{Boolean}
{\true}
{Always}
{If false, a sparse direct solver
will be used. The direct solver is faster for small (i.e. low-resolution) problems and always yields a solution
(as long as there is sufficient memory).
For large (high resolution) problems, the iterative solver will usually be faster and will use much
 less memory, but it may not always converge.
}

\myhrule

\param{whichParallelSolverToFactorPreconditioner}
{integer}
{1}
{Always}
{Which software package is used to $LU$-factorize the preconditioner matrix.\\

{\ttfamily whichParallelSolverToFactorPreconditioner} = 1: Use \mumps~if it is available, otherwise use \superludist.\\

{\ttfamily whichParallelSolverToFactorPreconditioner} = 2: Force use of \superludist~ even if \mumps~is available.
}

\myhrule

\param{PETSCPreallocationStrategy}
{integer}
{1}
{Always}
{This setting changes the estimated number of nonzeros (nnz) used for allocating memory for the system matrix and preconditioner.\\

{\ttfamily PETSCPreallocationStrategy} = 0: Old method with high estimated nnz. This method involves relatively simpler code but uses WAY more memory than necessary.\\

{\ttfamily PETSCPreallocationStrategy} = 1: New method with lower, more precise estimated nnz.  This method should use much less memory.\\

Use {\ttfamily PETSCPreallocationStrategy} = 1 unless you know what you are doing.}


\myhrule

\paramWithUnderscore{Nxi\_for\_x\_option}{Nxi_for_x_option}
{integer}
{1}
{Always}
{This setting controls how the number of Legendre polynomials depends on the speed $x$ for representing the distribution function.
You can see the actual number of Legendre polynomials used for each $x$ grid point by examining the {\ttfamily Nxi\_for\_x} variable
in the output file.\\

{\ttfamily Nxi\_for\_x\_option} = 0: Use the same number (\parlink{Nxi}) of Legendre polynomials for all $x$.  This approach is
simplest, but it is somewhat inefficient since small values of $x$ represent higher collisionality, so there is weaker pitch-angle dependence
of the distribution function.\\

{\ttfamily Nxi\_for\_x\_option} = 1: The number of Legendre polynomials will be a linear function of $x$ up to $x=2$,
at which point \parlink{Nxi} polynomials will be used. For $x>2$, the number of Legendre polynomials used will remain at \parlink{Nxi}.\\

{\ttfamily Nxi\_for\_x\_option} = 2: The number of Legendre polynomials will be a quadratic function of $x$ up to $x=2$,
at which point \parlink{Nxi} polynomials will be used. For $x>2$, the number of Legendre polynomials used will remain at \parlink{Nxi}.\\

}









\section{The {\ttfamily preconditionerOptions}~namelist}
\label{sec:preconditionerOptions}

This namelist controls how elements are removed from the ``real'' matrix in order to obtain
the preconditioner matrix. The default values are usually best, but if you find that there are more than 100 iterations
of GMRES/KSP, it may be worth adjusting these settings.  As long as KSP converges, these parameters
should have no impact (to several digits) on the physical outputs such as parallel flows and radial fluxes.
Therefore, do not worry about (for example) ``dropping coupling between species'' in the first
parameter below, since full inter-species coupling will be retained in the real equations that are being solved.

\myhrule

\paramWithUnderscore{preconditioner\_species}{preconditioner_species}
{integer}
{1}
{Whenever \parlink{useIterativeLinearSolver} = \true~and there are 2 or more species.}
{\\
{\ttfamily preconditioner\_species} = 0: Keep all coupling between species.\\

{\ttfamily preconditioner\_species} = 1: Drop all coupling between species.\\

The default value of 1 is recommended, except perhaps at high collisionality where 0 may be preferable.}

\myhrule

\paramWithUnderscore{preconditioner\_x}{preconditioner_x}
{integer}
{1}
{Whenever \parlink{useIterativeLinearSolver} = \true~and \parlink{RHSMode} = 1 or 2.}
{\\
{\ttfamily preconditioner\_x} = 0: Keep full $x$ coupling.\\

{\ttfamily preconditioner\_x} = 1: Drop everything off-diagonal in $x$.\\

{\ttfamily preconditioner\_x} = 2: Keep only upper-triangular part in $x$.\\

{\ttfamily preconditioner\_x} = 3: Keep only the tridiagonal terms in $x$.\\

{\ttfamily preconditioner\_x} = 4: Keep only the diagonal and superdiagonal in $x$.\\

The default value of 1 is strongly recommended, except perhaps at high collisionality where 0 may be preferable.}

\myhrule

\paramWithUnderscore{preconditioner\_x\_min\_L}{preconditioner_x_min_L}
{integer}
{0}
{Whenever \parlink{useIterativeLinearSolver} = \true~and \parlink{RHSMode} = 1 or 2 and \underscoreparlink{preconditioner\_x}{preconditioner_x} $>$ 0.}
{The $x$ structure of the matrix will only be simplified for Legendre index $L$ is $\ge$ this value.
Set {\ttfamily preconditioner\_x\_min\_L} = 0 to simplify the matrix for every $L$.
Recommended values are 0, 1, or 2.}

\myhrule

\paramWithUnderscore{preconditioner\_theta}{preconditioner_theta}
{integer}
{0}
{Whenever \parlink{useIterativeLinearSolver} = \true}
{\\
{\ttfamily preconditioner\_theta} = 0: Keep full $\theta$ coupling.\\

{\ttfamily preconditioner\_theta} = 1: Use a 3-point finite difference stencil for $d/d\theta$.\\

{\ttfamily preconditioner\_theta} = 2: Drop all $\theta$ coupling.\\

{\ttfamily preconditioner\_theta} = 3: Replace $d/d\theta$ with the identity matrix.\\

The default value of 0 is strongly recommended.}

\myhrule

\paramWithUnderscore{preconditioner\_theta\_min\_L}{preconditioner_theta_min_L}
{integer}
{0}
{Whenever \parlink{useIterativeLinearSolver} = \true~and \underscoreparlink{preconditioner\_theta}{preconditioner_theta} $>$ 0.}
{The $\theta$ structure of the matrix will only be simplified for Legendre index $L$ is $\ge$ this value.
Set {\ttfamily preconditioner\_theta\_min\_L} = 0 to simplify the matrix for every $L$.
}

\myhrule

\paramWithUnderscore{preconditioner\_zeta}{preconditioner_zeta}
{integer}
{0}
{Whenever \parlink{useIterativeLinearSolver} = \true}
{\\
{\ttfamily preconditioner\_zeta} = 0: Keep full $\zeta$ coupling.\\

{\ttfamily preconditioner\_zeta} = 1: Use a 3-point finite difference stencil for $d/d\zeta$.\\

{\ttfamily preconditioner\_zeta} = 2: Drop all $\zeta$ coupling.\\

{\ttfamily preconditioner\_zeta} = 3: Replace $d/d\zeta$ with the identity matrix.\\

The default value of 0 is strongly recommended.}

\myhrule

\paramWithUnderscore{preconditioner\_zeta\_min\_L}{preconditioner_zeta_min_L}
{integer}
{0}
{Whenever \parlink{useIterativeLinearSolver} = \true~and \underscoreparlink{preconditioner\_zeta}{preconditioner_zeta} $>$ 0.}
{The $\zeta$ structure of the matrix will only be simplified for Legendre index $L$ is $\ge$ this value.
Set {\ttfamily preconditioner\_zeta\_min\_L} = 0 to simplify the matrix for every $L$.
}

\myhrule

\paramWithUnderscore{preconditioner\_xi}{preconditioner_xi}
{integer}
{1}
{Whenever \parlink{useIterativeLinearSolver} = \true}
{\\
{\ttfamily preconditioner\_xi} = 0: Keep full $\xi$ coupling.\\

{\ttfamily preconditioner\_xi} = 1: Drop terms that are $\pm 2$ rows from the diagonal in $\xi$, 
      so the preconditioner matrix becomes tridiagonal in $\xi$.
(Normally the preconditioner matrix is pentadiagonal in $\xi$.)\\

Either a setting of 0 or 1 can be good for this parameter.}

\myhrule

\paramWithUnderscore{preconditioner\_magnetic\_drifts\_max\_L}{preconditioner_magnetic_drifts_max_L}
{integer}
{2}
{Whenever \parlink{useIterativeLinearSolver} = \true and \parlink{magneticDriftScheme}$>0$}
{Maximum Legendre mode number for which the poloidal and toroidal magnetic drift terms are included in the preconditioner.
As this parameter is increased, more memory is required for factorization, but fewer KSP iterations are required.
Setting this parameter to $\ge$ \parlink{Nxi} means that the magnetic drifts are always included in the preconditioner.
Setting this parameter to $<0$ means the magnetic drifts are never included in the preconditioner.
The default value should be good.}

\myhrule

\param{reusePreconditioner}
{Boolean}
{\true}
{Only when \parlink{includePhi1} = \true  and \parlink{readExternalPhi1} == \false}
{If true, the nonlinear term will not be included in the preconditioner matrix, meaning the preconditioner matrix is the same
at every iteration, and so the preconditioner matrix only needs to be $LU$-factorized once.  If false, the preconditioner matrix
for the Jacobian will be different at each iteration of the Newton solve, so the preconditioner needs to be $LU$-factorized at
each iteration.  The nonlinear term also introduces a lot of nonzeros into the preconditioner matrix, so setting
{\ttfamily reusePreconditioner =}\true~not only dramatically reduces the time required for a nonlinear calculation, but also the memory required.}










\section{The {\ttfamily export\_f}~namelist}
\label{sec:exportfParameters}

This namelist controls whether and how the distribution function is saved in {\ttfamily sfincsOutput.h5}.
For each of the 4 coordinates $(\theta, \zeta, x, \xi)$, the distribution function can be given with the same discretization
used for solving the kinetic equation, or you can interpolate to a different grid/discretization.
For all available settings, the distribution function will be reported on a tensor product grid in the 4 coordinates.

\myhrule

\paramWithUnderscore{export\_full\_f}{export_full_f}
{Boolean}
{\false}
{Always}
{Whether or not to save the full distribution function (the sum of the leading-order Maxwellian and the departure from it)
in the output file.}

\myhrule

\paramWithUnderscore{export\_delta\_f}{export_delta_f}
{Boolean}
{\false}
{Always}
{Whether or not to save the departure from a Maxwellian distribution function in the output file.}

\myhrule

\paramWithUnderscore{export\_f\_theta\_option}{export_f_theta_option}
{integer}
{2}
{Whenever \underscoreparlink{export\_full\_f}{export_full_f} or \underscoreparlink{export\_delta\_f}{export_delta_f} is \true}
{Controls which grid in $\theta$ is used for exporting the distribution function.\\

{\ttfamily export\_f\_theta\_option} = 0: Report the distribution function on the original $\theta$ grid (with \Ntheta~points) used for solving the kinetic equation.\\

{\ttfamily export\_f\_theta\_option} = 1: Interpolate to a different grid, specified by \underscoreparlink{export\_f\_theta}{export_f_theta}. Linear interpolation will be used.
No sorting of the requested values is performed.\\

{\ttfamily export\_f\_theta\_option} = 2: Do not interpolate. Use the
values of the $\theta$ grid that are closest to the values requested
in \underscoreparlink{export\_f\_theta}{export_f_theta}.  Values of $\theta$ will be in
increasing order. If multiple requested values are close to the same
grid point, the number of points returned will be less than the number
of points requested. \\

For all of these options, you can see \underscoreparlink{export\_f\_theta}{export_f_theta} in {\ttfamily sfincsOutput.h5} for the actual grid used in the end.
}

\myhrule

\paramWithUnderscore{export\_f\_zeta\_option}{export_f_zeta_option}
{integer}
{2}
{Whenever \underscoreparlink{export\_full\_f}{export_full_f} or \underscoreparlink{export\_delta\_f}{export_delta_f} is \true}
{Controls which grid in $\zeta$ is used for exporting the distribution function.\\

{\ttfamily export\_f\_zeta\_option} = 0: Report the distribution function on the original $\zeta$ grid (with \Nzeta~points) used for solving the kinetic equation.\\

{\ttfamily export\_f\_zeta\_option} = 1: Interpolate to a different grid, specified by \underscoreparlink{export\_f\_zeta}{export_f_zeta}. Linear interpolation will be used.
No sorting of the requested values is performed.\\

{\ttfamily export\_f\_zeta\_option} = 2: Do not interpolate. Use the
values of the $\zeta$ grid that are closest to the values requested
in \underscoreparlink{export\_f\_zeta}{export_f_zeta}.  Values of $\zeta$ will be in
increasing order. If multiple requested values are close to the same
grid point, the number of points returned will be less than the number
of points requested. \\

For all of these options, you can see \underscoreparlink{export\_f\_zeta}{export_f_zeta} in {\ttfamily sfincsOutput.h5} for the actual grid used in the end.
}

\myhrule

\paramWithUnderscore{export\_f\_theta}{export_f_theta}
{1D array of reals}
{0.0}
{Whenever \underscoreparlink{export\_full\_f}{export_full_f} or \underscoreparlink{export\_delta\_f}{export_delta_f} is \true, and \underscoreparlink{export\_f\_theta\_option}{export_f_theta_option} $>0$.}
{Values of $\theta$ on which you want to save the distribution function.  modulo$(\ldots, 2\pi)$ will be applied.  See \underscoreparlink{export\_f\_theta\_option}{export_f_theta_option} for details}


\myhrule

\paramWithUnderscore{export\_f\_zeta}{export_f_zeta}
{1D array of reals}
{0.0}
{Whenever \underscoreparlink{export\_full\_f}{export_full_f} or \underscoreparlink{export\_delta\_f}{export_delta_f} is \true, and \underscoreparlink{export\_f\_zeta\_option}{export_f_zeta_option} $>0$.}
{Values of $\zeta$ on which you want to save the distribution function.  modulo$(\ldots, 2\pi/\mbox{\ttfamily NPeriods})$ will be applied.  See \underscoreparlink{export\_f\_zeta\_option}{export_f_zeta_option} for details}

\myhrule

\paramWithUnderscore{export\_f\_xi\_option}{export_f_xi_option}
{integer}
{1}
{Whenever \underscoreparlink{export\_full\_f}{export_full_f} or \underscoreparlink{export\_delta\_f}{export_delta_f} is \true}
{Controls which discretization in $\xi$ is used for exporting the distribution function.\\

{\ttfamily export\_f\_xi\_option} = 0: Report the distribution function as amplitudes of \Nxi~Legendre polynomials, as used internally by \sfincs~for solving the kinetic equation.\\

{\ttfamily export\_f\_xi\_option} = 1: Report the distribution function on the values of $\xi$ specified by \underscoreparlink{export\_f\_xi}{export_f_xi}. No sorting of the requested values is performed.
}

\myhrule

\paramWithUnderscore{export\_f\_xi}{export_f_xi}
{1D array of reals}
{0.0}
{Whenever \underscoreparlink{export\_full\_f}{export_full_f} or \underscoreparlink{export\_delta\_f}{export_delta_f} is \true, and \underscoreparlink{export\_f\_xi\_option}{export_f_xi_option} = 1.}
{Values of $\xi$ on which you want to save the distribution function.  Values must lie in the range $[-1,1]$.}

\myhrule

\paramWithUnderscore{export\_f\_x\_option}{export_f_x_option}
{integer}
{0}
{Whenever \underscoreparlink{export\_full\_f}{export_full_f} or \underscoreparlink{export\_delta\_f}{export_delta_f} is \true}
{Controls which grid in $x = v/\sqrt{2T/m}$ is used for exporting the distribution function.\\

{\ttfamily export\_f\_x\_option} = 0: Report the distribution function on the original $x$ grid (with \Nx~points) used for solving the kinetic equation.\\

{\ttfamily export\_f\_x\_option} = 1: Interpolate to a different grid, specified by \underscoreparlink{export\_f\_x}{export_f_x}.  Polynomial spectral interpolation will be used.
  No sorting of the requested values is performed.\\

{\ttfamily export\_f\_x\_option} = 2: Do not interpolate. Use the values of the internal $x$ grid that are closest to the values requested in \underscoreparlink{export\_f\_x}{export_f_x}.
  Values of $x$ will be in increasing order. If multiple requested values are close to the same grid point, the number of
  points returned will be less than the number of points requested.\\

For all of these options, you can see \underscoreparlink{export\_f\_x}{export_f_x} in {\ttfamily sfincsOutput.h5} for the actual grid used in the end.
}

\myhrule

\paramWithUnderscore{export\_f\_x}{export_f_x}
{1D array of reals}
{1.0}
{Whenever \underscoreparlink{export\_full\_f}{export_full_f} or \underscoreparlink{export\_delta\_f}{export_delta_f} is \true, and \underscoreparlink{export\_f\_x\_option}{export_f_x_option} $>0$.}
{Values of $x$ on which you want to save the distribution function.  Values must be $\ge 0$.}




\section{The \texttt{adjointOptions} namelist}
\label{sec:adjointOptions}

This namelist allows for derivatives of the outputs to be computed with respect to geometric parameters. If \parlink{RHSMode}\texttt{<4}, this namelist will not be read. 

\param{adjointBootstrapOption}
{Boolean}
{\false}
{When \parlink{RHSMode} == 4 or 5}
{If this parameter is \true, the derivative of the bootstrap current (\parlink{FSABjHatOverRootFSAB2}) is computed with respect to geometry parameters: \parlink{GHat}, \parlink{IHat}, \parlink{iota}, and \parlink{bmnc}.}

\myhrule

\param{adjointRadialCurrentOption}
{Boolean}
{\false}
{When \parlink{RHSMode} == 4 or 5}
{If this parameter is \true the derivative of the radial current,
\begin{gather}
J_r = \sum_s \texttt{Zs}(s) \texttt{particleFlux\_vm\_rN}(s),
\end{gather}
is computed with respect to geometry parameters: \parlink{GHat}, \parlink{IHat}, \parlink{iota}, and \parlink{bmnc}. Here \parlink{Zs} and \parlink{particleFlux\_vm\_rN} can be found elsewhere in this document.}

\myhrule

\param{adjointTotalHeatFluxOption}
{Boolean}
{\false}
{When \parlink{RHSMode} == 4 or 5}
{If this parameter is \true, the derivative of the total heat flux,
\begin{gather}
Q = \sum_s \texttt{heatFlux\_vm\_rN}(s),
\end{gather}
is computed with respect to geometry parameters: \parlink{GHat}, \parlink{IHat}, \parlink{iota}, and \parlink{bmnc}. Here \parlink{heatFlux\_vm\_rN} can be found elsewhere in this document.}

\myhrule

\param{adjointHeatFluxOption}
{1D array of booleans}
{\false}
{When \parlink{RHSMode} == 4 or 5}
{This array is the same length as {\ttfamily nHats} and other species parameters. If parameter is \true, the derivative of the heat flux (\parlink{heatFlux\_vm\_rN}) will be computed for this species with respect to geometry parameters: \parlink{GHat}, \parlink{IHat}, \parlink{iota}, and \parlink{bmnc}.}

\myhrule

\param{adjointParticleFluxOption}
{1D array of booleans}
{\false}
{When \parlink{RHSMode} == 4 or 5}
{This array is the same length as {\ttfamily nHats} and other species parameters. If parameter is \true, the derivative of the particle flux (\parlink{particleFlux\_vm\_rN}) will be computed for this species with respect to geometry parameters: \parlink{GHat}, \parlink{IHat}, \parlink{iota}, and \parlink{bmnc}.}

\myhrule

\param{adjointParallelFlowOption}
{1D array of booleans}
{\false}
{When \parlink{RHSMode} == 4 or 5}
{This array is the same length as {\ttfamily nHats} and other species parameters. If parameter is \true, the derivative of the parallel flow (\parlink{FSABVelocityUsingFSADensityOverRootFSAB2}) will be computed for this species with respect to geometry parameters: \parlink{GHat}, \parlink{IHat}, \parlink{iota}, and \parlink{bmnc}.}

\myhrule

\param{discreteAdjointOption}
{boolean}
{\true}
{When \parlink{RHSMode} == 4 or 5}
{When \parlink{RHSMode} is \true, the discrete adjoint technique is used. If \false, the continuous technique is used. Both should give the same result within discretization error, but the discrete approach should be slightly faster.
}

\myhrule

\param{nMaxAdjoint}
{integer}
{0}
{When \parlink{RHSMode} == 4 or 5}
{Derivatives of outputs specified by \parlink{adjointBootstrapOption}, \\ \parlink{adjointRadialCurrentOption}, \parlink{adjointTotalHeatFluxOption}, \\ \parlink{adjointHeatFluxOption}, \parlink{adjointParticleFluxOption}, and \\ \parlink{adjointParallelFlowOption} will computed for Fourier modes $|n| \leq $ \texttt{nMaxAdjoint}. }

\myhrule

\param{mMaxAdjoint}
{integer}
{0}
{When \parlink{RHSMode} == 4 or 5}
{Derivatives of outputs specified by \parlink{adjointBootstrapOption}, \\ \parlink{adjointRadialCurrentOption}, \parlink{adjointTotalHeatFluxOption}, \\ \parlink{adjointHeatFluxOption}, \parlink{adjointParticleFluxOption}, and \\ \parlink{adjointParallelFlowOption} will computed with respect to \parlink{bmnc} for Fourier modes $m \leq $ \texttt{mMaxAdjoint}. }

\myhrule

\param{nMinAdjoint}
{integer}
{0}
{When \parlink{RHSMode} == 4 or 5}
{Derivatives of outputs specified by \parlink{adjointBootstrapOption}, \\ \parlink{adjointRadialCurrentOption}, \parlink{adjointTotalHeatFluxOption}, \\ \parlink{adjointHeatFluxOption}, \parlink{adjointParticleFluxOption}, and \\ \parlink{adjointParallelFlowOption} will computed with respect to \parlink{bmnc} for Fourier modes $|n| \geq $ \texttt{nMaxAdjoint}. }

\myhrule

\param{mMinAdjoint}
{integer}
{0}
{When \parlink{RHSMode} == 4 or 5}
{Derivatives of outputs specified by \parlink{adjointBootstrapOption}, \\ \parlink{adjointRadialCurrentOption}, \parlink{adjointTotalHeatFluxOption}, \\ \parlink{adjointHeatFluxOption}, \parlink{adjointParticleFluxOption}, and \\ \parlink{adjointParallelFlowOption} will computed with respect to \parlink{bmnc} for Fourier modes $m \geq $ \texttt{mMaxAdjoint}. }

\myhrule

\param{debugAdjoint}
{boolean}
{\false}
{When \parlink{RHSMode} == 4 or 5. }
{If \texttt{.true.}, then derivatives computed with the adjoint method will be compared with forward difference derivatives with step size set by \parlink{deltaLambda}.}

\myhrule

\param{deltaLambda}
{real}
{1.d-4}
{When \parlink{deltaLamda} == \texttt{.true.}}
{The step size used for forward difference derivatives will be \texttt{deltaLambda} multiplied by the quantity that is being varied. For example, the step size for a Boozer harmonic, $B_{mn}$, would be $\Delta B_{mn} = $\texttt{deltaLambda}$B_{mn}$.}

\myhrule













\section{Directives for \sfincsScan}
\label{sec:sfincsScanParams}

The parameters for \sfincsScan~ begin with the code {\ttfamily !ss} and so are not read by the fortran part of \sfincs.
These parameters matter only when \sfincsScan~is called and are all ignored when \sfincs~is executed directly.
These parameters can appear anywhere in the {\ttfamily input.namelist} file, in any namelist or outside of any namelist.
Note that \sfincsScan~ parameters do not have defaults, unlike fortran namelist parameters.\\


\myhrule

\ssparam{scanType}
{integer}
{Any time \sfincsScan~is called.}
{Which type of scan will be run when \sfincsScan~is called. \\

{\ttfamily scanType} = 1:  Resolution convergence scan. (Scan the parameters in the resolutionParameters namelist.)\\

{\ttfamily scanType} = 2:  Scan of $E_r$.\\

{\ttfamily scanType} = 3:  Scan any one input parameter that takes a numeric value.\\

{\ttfamily scanType} = 4:  Scan radius, taking the density and temperature profiles from the {\ttfamily profiles} file.
In this type of scan, the same radial electric field is used at every radius.
See \path{sfincs/fortran/utils/profiles.XXX} for examples.\\

{\ttfamily scanType} = 5:  Scan radius, and at each radius, scan $E_r$.  Density and temperature profiles are again
 taken from the {\ttfamily profiles} file; see \path{sfincs/fortran/utils/profiles.XXX} for examples.
In this type of scan, \sfincsScan~creates a subdirectory for each value of minor radius, and a
{\ttfamily scanType} = 2 scan is run in each of these subdirectories.
\\

{\ttfamily scanType} = 21: Read in a list of requested runs from a
file {\ttfamily runspec.dat}. See
\path{sfincs/fortran/utils/sfincsScan_21} for an example file. If the
file has a different name than {\ttfamily runspec.dat}, for instance
{\ttfamily thefilename.dat}, this name can be
specified by adding the line\\
{\ttfamily
!ss runSpecFile = thefilename.dat\\}

{\ttfamily scanType} = 22: Similar to {\ttfamily scanType}=5 but the
radial scan is specified with a runspec file like for {\ttfamily
  scanType}=21. For each line in the {\ttfamily runspec.dat} file a
directory is created, in which a {\ttfamily scanType}=2 $E_r$ scan is started.\\
}



\subsection{Parameters related only to {\ttfamily scanType} = 1 (resolution convergence scans).}
\label{sec:scanType1Parameters}

The resolution parameters discussed in section \ref{sec:resolutionParameters}
each have 3 associated \sfincsScan~parameters
which are used for convergence scans (\parlink{scanType} = 1): {\ttfamily ...MinFactor}, {\ttfamily ...MaxFactor}, and {\ttfamily ...NumRuns}.
The first two of these set the range by which the associated resolution parameter is scaled
in a convergence scan. The {\ttfamily ...NumRuns} parameter sets the number of values tried in a
convergence scan. The code attempts to space the values evenly in a logarithmic
sense, as in Matlab's 'logspace' function. For example, the following settings\\
{\ttfamily
    Nxi = 20\\
!ss NxiMinFactor = 0.5\\
!ss NxiMaxFactor = 2.0\\
!ss NxiNumRuns = 3\\
}
would mean the values \Nxi = 10, 20, and 40 would be tried in a convergence scan.
If you don't want to scan a variable in a convergence scan, set the associated
{\ttfamily ...NumRuns} parameter to 0, or do not include this parameter in the input file.
For each resolution parameter (\Ntheta, \Nzeta, \Nxi, etc.), the value itself is read by
Fortran and so should not be preceded by {\ttfamily !ss}.  However the {\ttfamily ...MinFactor}, {\ttfamily ...MaxFactor}, and {\ttfamily ...NumRuns}
quantities are read by \sfincsScan~and so must be preceded by {\ttfamily !ss}

\myhrule

\ssparam{NthetaMaxFactor}
{real}
{Only when \sfincsScan~is run with \parlink{scanType} = 1.}
{Maximum factor by which \Ntheta~will be multiplied in a convergence scan.}

\myhrule

\ssparam{NthetaMinFactor}
{real}
{Only when \sfincsScan~is run with \parlink{scanType} = 1.}
{Minimum factor by which \Ntheta~will be multiplied in a convergence scan.}

\myhrule

\ssparam{NthetaNumRuns}
{integer}
{Only when \sfincsScan~is run with \parlink{scanType} = 1.}
{Maximum number of values of \Ntheta~which will be used in a convergence scan.  Only odd integers can be used
for \Ntheta, so the actual number of \Ntheta~values used in the scan may be less than {\ttfamily NthetaNumRuns}.}

\myhrule

\ssparam{NzetaMaxFactor}
{real}
{Only when \sfincsScan~is run with \parlink{scanType} = 1.}
{Maximum factor by which \Nzeta~will be multiplied in a convergence scan.}

\myhrule

\ssparam{NzetaMinFactor}
{real}
{Only when \sfincsScan~is run with \parlink{scanType} = 1.}
{Minimum factor by which \Nzeta~will be multiplied in a convergence scan.}

\myhrule

\ssparam{NzetaNumRuns}
{integer}
{Only when \sfincsScan~is run with \parlink{scanType} = 1.}
{Maximum number of values of \Nzeta~which will be used in a convergence scan.  Only odd integers can be used
for \Nzeta, so the actual number of \Nzeta~values used in the scan may be less than {\ttfamily NzetaNumRuns}.}

\myhrule

\ssparam{NxiMaxFactor}
{real}
{Only when \sfincsScan~is run with \parlink{scanType} = 1.}
{Maximum factor by which \Nxi~will be multiplied in a convergence scan.}

\myhrule

\ssparam{NxiMinFactor}
{real}
{Only when \sfincsScan~is run with \parlink{scanType} = 1.}
{Minimum factor by which \Nxi~will be multiplied in a convergence scan.}

\myhrule

\ssparam{NxiNumRuns}
{integer}
{Only when \sfincsScan~is run with \parlink{scanType} = 1.}
{Maximum number of values of \Nxi~which will be used in a convergence scan.  Only integers can be used
for \Nxi, so the actual number of \Nxi~values used in the scan may be less than {\ttfamily NxiNumRuns}.}

\myhrule

\ssparam{NxMaxFactor}
{real}
{Only when \sfincsScan~is run with \parlink{scanType} = 1.}
{Maximum factor by which \Nx~will be multiplied in a convergence scan.}

\myhrule

\ssparam{NxMinFactor}
{real}
{Only when \sfincsScan~is run with \parlink{scanType} = 1.}
{Minimum factor by which \Nx~will be multiplied in a convergence scan.}

\myhrule

\ssparam{NxNumRuns}
{integer}
{Only when \sfincsScan~is run with \parlink{scanType} = 1.}
{Maximum number of values of \Nx~which will be used in a convergence scan.  Only integers can be used
for \Nx, so the actual number of \Nx~values used in the scan may be less than {\ttfamily NxNumRuns}.}

\myhrule

\ssparam{solverToleranceMaxFactor}
{real}
{Only when \sfincsScan~is run with \parlink{scanType} = 1.}
{Maximum factor by which \parlink{solverTolerance} will be multiplied in a convergence scan.}

\myhrule

\ssparam{solverToleranceMinFactor}
{real}
{Only when \sfincsScan~is run with \parlink{scanType} = 1.}
{Minimum factor by which \parlink{solverTolerance} will be multiplied in a convergence scan.}

\myhrule

\ssparam{solverToleranceNumRuns}
{integer}
{Only when \sfincsScan~is run with \parlink{scanType} = 1.}
{Number of values of \parlink{solverTolerance} which will be used in a convergence scan.}

\myhrule

\ssparam{NLMaxFactor}
{real}
{Only when \parlink{collisionOperator} = 0 and \sfincsScan~is run with \parlink{scanType} = 1.}
{Maximum factor by which \NL~will be multiplied in a convergence scan.}

\myhrule

\ssparam{NLMinFactor}
{real}
{Only when \parlink{collisionOperator} = 0 and \sfincsScan~is run with \parlink{scanType} = 1.}
{Minimum factor by which \NL~will be multiplied in a convergence scan.}

\myhrule

\ssparam{NLNumRuns}
{integer}
{Only when \parlink{collisionOperator} = 0 and \sfincsScan~is run with \parlink{scanType} = 1.}
{Maximum number of values of \NL~which will be used in a convergence scan.  Only integers can be used
for \NL, so the actual number of \NL~values used in the scan may be less than {\ttfamily NLNumRuns}.}

\myhrule

\ssparam{NxPotentialsPerVthMaxFactor}
{real}
{Only when \parlink{collisionOperator} = 0, \parlink{xGridScheme} $<$ 5, and \sfincsScan~is run with \parlink{scanType} = 1.
Since the recommended value of \parlink{xGridScheme} is 5, this parameter is basically obsolete.}
{Maximum factor by which \parlink{NxPotentialsPerVth} will be multiplied in a convergence scan.}

\myhrule

\ssparam{NxPotentialsPerVthMinFactor}
{real}
{Only when \parlink{collisionOperator} = 0, \parlink{xGridScheme} $<$ 5, and \sfincsScan~is run with \parlink{scanType} = 1.
Since the recommended value of \parlink{xGridScheme} is 5, this parameter is basically obsolete.}
{Minimum factor by which \parlink{NxPotentialsPerVth} will be multiplied in a convergence scan.}

\myhrule

\ssparam{NxPotentialsPerVthNumRuns}
{integer}
{Only when \parlink{collisionOperator} = 0, \parlink{xGridScheme} $<$ 5, and \sfincsScan~is run with \parlink{scanType} = 1.
Since the recommended value of \parlink{xGridScheme} is 5, this parameter is basically obsolete.}
{Number of values of \parlink{NxPotentialsPerVth} which will be used in a convergence scan.}

\myhrule

\ssparam{xMaxMaxFactor}
{real}
{Only when \parlink{collisionOperator} = 0, \parlink{xGridScheme} $<$ 5, and \sfincsScan~is run with \parlink{scanType} = 1.
Since the recommended value of \parlink{xGridScheme} is 5, this parameter is basically obsolete.}
{Maximum factor by which \parlink{xMax} will be multiplied in a convergence scan.}

\myhrule

\ssparam{xMaxMinFactor}
{real}
{Only when \parlink{collisionOperator} = 0, \parlink{xGridScheme} $<$ 5, and \sfincsScan~is run with \parlink{scanType} = 1.
Since the recommended value of \parlink{xGridScheme} is 5, this parameter is basically obsolete.}
{Minimum factor by which \parlink{xMax} will be multiplied in a convergence scan.}

\myhrule

\ssparam{xMaxNumRuns}
{integer}
{Only when \parlink{collisionOperator} = 0, \parlink{xGridScheme} $<$ 5, and \sfincsScan~is run with \parlink{scanType} = 1.
Since the recommended value of \parlink{xGridScheme} is 5, this parameter is basically obsolete.}
{Number of values of \parlink{xMax} which will be used in a convergence scan.}




\subsection{Parameters related only to {\ttfamily scanType} = 2 (scans of radial electric field).}

In this scan of the radial electric field, the values of electric field used
will always be uniformly (linearly) spaced.  
Notice that exactly 1 of the 5 variables \parlink{dPhiHatdpsiHatMax}, \parlink{dPhiHatdpsiNMax}, \parlink{dPhiHatdrHatMax}, \parlink{dPhiHatdrNMax}, or \parlink{ErMax}
will be used, depending on\\
\parlink{inputRadialCoordinateForGradients}.
Similarly, exactly 1 of the 5 variables
\parlink{dPhiHatdpsiHatMin}, \parlink{dPhiHatdpsiNMin}, \parlink{dPhiHatdrHatMin}, \parlink{dPhiHatdrNMin}, or \parlink{ErMin}
will be used.

\myhrule

\ssparam{NErs}
{integer}
{Only when \sfincsScan~is run with \parlink{scanType} = 2.}
{Number of values of radial electric field to consider in a scan.}

\myhrule

\ssparam{dPhiHatdpsiHatMax}
{real}
{Only when \parlink{inputRadialCoordinateForGradients} = 0 and \sfincsScan~is run with \parlink{scanType} = 2.}
{Maximum value of \parlink{dPhiHatdpsiHat} to use in the scan.}

\myhrule

\ssparam{dPhiHatdpsiHatMin}
{real}
{Only when \parlink{inputRadialCoordinateForGradients} = 0 and \sfincsScan~is run with \parlink{scanType} = 2.}
{Minimum value of \parlink{dPhiHatdpsiHat} to use in the scan.}

\myhrule

\ssparam{dPhiHatdpsiNMax}
{real}
{Only when \parlink{inputRadialCoordinateForGradients} = 1 and \sfincsScan~is run with \parlink{scanType} = 2.}
{Maximum value of \parlink{dPhiHatdpsiN} to use in the scan.}

\myhrule

\ssparam{dPhiHatdpsiNMin}
{real}
{Only when \parlink{inputRadialCoordinateForGradients} = 1 and \sfincsScan~is run with \parlink{scanType} = 2.}
{Minimum value of \parlink{dPhiHatdpsiN} to use in the scan.}

\myhrule

\ssparam{dPhiHatdrHatMax}
{real}
{Only when \parlink{inputRadialCoordinateForGradients} = 2 and \sfincsScan~is run with \parlink{scanType} = 2.}
{Maximum value of \parlink{dPhiHatdrHat} to use in the scan.}

\myhrule

\ssparam{dPhiHatdrHatMin}
{real}
{Only when \parlink{inputRadialCoordinateForGradients} = 2 and \sfincsScan~is run with \parlink{scanType} = 2.}
{Minimum value of \parlink{dPhiHatdrHat} to use in the scan.}

\myhrule

\ssparam{dPhiHatdrNMax}
{real}
{Only when \parlink{inputRadialCoordinateForGradients} = 3 and \sfincsScan~is run with \parlink{scanType} = 2.}
{Maximum value of \parlink{dPhiHatdrN} to use in the scan.}

\myhrule

\ssparam{dPhiHatdrNMin}
{real}
{Only when \parlink{inputRadialCoordinateForGradients} = 3 and \sfincsScan~is run with \parlink{scanType} = 2.}
{Minimum value of \parlink{dPhiHatdrN} to use in the scan.}

\myhrule

\ssparam{ErMax}
{real}
{Only when \parlink{inputRadialCoordinateForGradients} = 4 and \sfincsScan~is run with \parlink{scanType} = 2.}
{Maximum value of \parlink{Er} to use in the scan.}

\myhrule

\ssparam{ErMin}
{real}
{Only when \parlink{inputRadialCoordinateForGradients} = 4 and \sfincsScan~is run with \parlink{scanType} = 2.}
{Minimum value of \parlink{Er} to use in the scan.}

\subsection{Parameters related only to {\ttfamily scanType} = 3 (scans of an arbitrary input parameter).}

\ssparam{scanVariable}
{string. Must be of the fortran namelist parameters that takes an integer or real value. Case-insensitive.}
{Only when \sfincsScan~is run with \parlink{scanType} = 3.}
{Name of the variable to scan in a \parlink{scanType} = 3 scan.}

\myhrule

\ssparam{scanVariableMax}
{real}
{Only when \sfincsScan~is run with \parlink{scanType} = 3.}
{Maximum value of \parlink{scanVariable} to use in a \parlink{scanType} = 3 scan.}

\myhrule

\ssparam{scanVariableMin}
{real}
{Only when \sfincsScan~is run with \parlink{scanType} = 3.}
{Minimum value of \parlink{scanVariable} to use in a \parlink{scanType} = 3 scan.}

\myhrule

\ssparam{scanVariableN}
{integer}
{Only when \sfincsScan~is run with \parlink{scanType} = 3.}
{Number of values of \parlink{scanVariable} to use in a \parlink{scanType} = 3 scan.}

\myhrule

\ssparam{scanVariableScale}
{string. Must be `linear', `lin', 'logarithmic', or 'log'}
{Only when \sfincsScan~is run with \parlink{scanType} = 3.}
{Whether to space the values of \parlink{scanVariable} in a linear or logarithmic manner.
The settings `linear' and `lin' have identical behavior. 
The settings `logarithmic' and `log' have identical behavior.}

\myhrule


\subsection{Parameters related only to {\ttfamily scanType} = 4 or 5 (radial scans).}

Notice that exactly 1 of the 4 variables \underscoreparlink{psiHat\_max}{psiHat_max}, \underscoreparlink{psiN\_max}{psiN_max}, \underscoreparlink{rHat\_max}{rHat_max}, and \underscoreparlink{rN\_max}{rN_max}
will be used, depending on
\parlink{inputRadialCoordinate}.
Similarly, exactly 1 of the 4 variables
\underscoreparlink{psiHat\_min}{psiHat_min}, \underscoreparlink{psiN\_min}{psiN_min}, \underscoreparlink{rHat\_min}{rHat_min}, and \underscoreparlink{rN\_min}{rN_min}
will be used.

\myhrule

\ssparam{profilesScheme}
{integer}
{Only when \sfincsScan~is run with \parlink{scanType} = 4 or 5.}
{How to specify the profiles of density, temperature, and (when  \parlink{scanType} = 5)
the range of radial electric field to consider.\\

{\ttfamily profilesScheme} = 1: Read a `{\ttfamily profiles}' file which contains the input profiles on a grid in one of the 4 available radial coordinates.\\

{\ttfamily profilesScheme} = 2: Read a `{\ttfamily profiles}' file which contains the input profiles expressed as polynomials in one of the 4 available radial coordinates.
}

\myhrule

\ssparam{Nradius}
{integer}
{Only when \sfincsScan~is run with \parlink{scanType} = 4 or 5.}
{Maximum number of values of minor radius to consider in the scan.
Depending on \parlink{geometryScheme} and \parlink{VMECRadialOption},
it may be that only surfaces available in the magnetic equilibrium file will be
used, in which case fewer than {\ttfamily Nradius} radii may be used.}

\myhrule

\ssparamWithUnderscore{psiHat\_max}{psiHat_max}
{real}
{Only when \parlink{inputRadialCoordinate} = 0 and \sfincsScan~is run with \parlink{scanType} = 4 or 5.}
{Maximum value of \parlink{psiHat} to use in the scan.}

\myhrule

\ssparamWithUnderscore{psiHat\_min}{psiHat_min}
{real}
{Only when \parlink{inputRadialCoordinate} = 0 and \sfincsScan~is run with \parlink{scanType} = 4 or 5.}
{Minimum value of \parlink{psiHat} to use in the scan.}

\myhrule

\ssparamWithUnderscore{psiN\_max}{psiN_max}
{real}
{Only when \parlink{inputRadialCoordinate} = 1 and \sfincsScan~is run with \parlink{scanType} = 4 or 5.}
{Maximum value of \parlink{psiN} to use in the scan.}

\myhrule

\ssparamWithUnderscore{psiN\_min}{psiN_min}
{real}
{Only when \parlink{inputRadialCoordinate} = 1 and \sfincsScan~is run with \parlink{scanType} = 4 or 5.}
{Minimum value of \parlink{psiN} to use in the scan.}

\myhrule

\ssparamWithUnderscore{rHat\_max}{rHat_max}
{real}
{Only when \parlink{inputRadialCoordinate} = 2 and \sfincsScan~is run with \parlink{scanType} = 4 or 5.}
{Maximum value of \parlink{rHat} to use in the scan.}

\myhrule

\ssparamWithUnderscore{rHat\_min}{rHat_min}
{real}
{Only when \parlink{inputRadialCoordinate} = 2 and \sfincsScan~is run with \parlink{scanType} = 4 or 5.}
{Minimum value of \parlink{rHat} to use in the scan.}

\myhrule

\ssparamWithUnderscore{rN\_max}{rN_max}
{real}
{Only when \parlink{inputRadialCoordinate} = 3 and \sfincsScan~is run with \parlink{scanType} = 4 or 5.}
{Maximum value of \parlink{rN} to use in the scan.}

\myhrule

\ssparamWithUnderscore{rN\_min}{rN_min}
{real}
{Only when \parlink{inputRadialCoordinate} = 3 and \sfincsScan~is run with \parlink{scanType} = 4 or 5.}
{Minimum value of \parlink{rN} to use in the scan.}


\section{\PETSc~commands}
\label{sec:PETScCommands}

Command-line flags can be used to modify the behavior of any \PETSc~application, including \sfincs.
There are hundreds of \PETSc~options, and a list can be obtained by running with the command-line flag
{\ttfamily -help}. Here we list some of the more useful options.\\

\PETScParam{-help}
{Dumps a list of available command-line options to stdout.}

\myhrule

\PETScParam{-ksp\_view}
{Dumps detailed information to stdout related to the linear solver.}

\myhrule

\PETScParam{-ksp\_gmres\_restart {\normalfont \ttfamily$<$integer$>$}}
{After how many iterations will GMRES restart. Default is 2000. The convergence of GMRES slows every time a restart occurs, but restarts also free up memory.
The memory required by GMRES is typically quite small compared to the memory required for the $LU$ factorization.}

\myhrule

\PETScParam{-pc\_factor\_mat\_solver\_package {\normalfont \ttfamily$<$packagename$>$}}
{Which sparse direct solver package is used to $LU$-factorize the preconditioner matrix.
%Options are given by the items in quotation marks  
%{\href{http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatSolverPackage.html#MatSolverPackage}{here.}}
This command-line flag overrides the related namelist parameter\\
\parlink{whichParallelSolverToFactorPreconditioner}.
See section \ref{sec:solvers} for further information about the available packages.
}

\section{\mumps~commands}
\label{sec:mumpsControlParameters}

The \mumps~solver package has many control parameters which are documented in the manual,
available \href{http://mumps-solver.org/}{here}.
In \sfincs, as in any \PETSc~application, these control parameters can be set
using the command-line flags {\ttfamily -mat\_mumps\_cntl\_X YYYY} (for floating point parameters)
and {\ttfamily -mat\_mumps\_icntl\_X YYYY} (for integer control parameters). 
Here, {\ttfamily X} is the numeric index of the control parameter,
and {\ttfamily YYYY} is the desired setting.
Here we list some of the more useful options.\\

\myhrule

\PETScParam{-mat\_mumps\_icntl\_4 {\normalfont \ttfamily$<$integer$>$}}
{How much diagnostic information will be printed by \mumps. Default is 3, causing extensive diagnostic information to be printed 
to standard output about the memory required for factorizing the preconditioner.
Set this parameter to 0 to suppress this output from mumps.}

\myhrule

\PETScParam{-mat\_mumps\_icntl\_14 {\normalfont \ttfamily$<$integer$>$}}
{Percentage margin allowed for increase of certain arrays during the $LU$ factorization.
The default value set by \sfincs~is 50 (higher than the original default value in \mumps.)
If \sfincs~exits with the \mumps~error {\ttfamily INFO(1)=-9}, then further increasing this parameter may help.}

\myhrule

\PETScParam{-mat\_mumps\_icntl\_22 1}
{Turns on the out-of-core solve capability,
which reduces the memory required at the cost of speed.
See section \ref{sec:parallelization} for further details.}

\myhrule

\PETScParam{-mat\_mumps\_icntl\_28 2}
{Uses one of the parallelized libraries ParMETIS or PT-SCOTCH for analyzing the matrix,
instead of the default serial algorithm.}


