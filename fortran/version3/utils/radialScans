#!/usr/bin/env python

# This script will not work if called directly.
# From the command line, you should call sfincsScan with scanType=4, which in turn calls sfincsScan_4, which in turn calls this script.

# The overall goal of this script is to build a list 'radii' of the radial locations to use for a scan,
# along with lists nHats, THats, dnHatdradius, and dTHatdradius for these radial locations.
# The 'directories' list will also be initialized.  (This list must be initialized
# The values of radii will correspond to the requested inputRadialCoordinate in the input.namelist file.
# The values of radii will be determined in part by the input.namelist !ss parameters Nradius, rN_min, rN_max, etc.
# If (geometryScheme=11 or geometryScheme=12 or (geometryScheme=5 and vmecRadialOption>0)) then the radii will be shifted to match
# the radii available in the magnetic equilibrium file.
# Profiles of density and temperature will be read in from the 'profiles' file.

profilesFilename = 'profiles'

import os, inspect
import numpy
from scipy import interpolate
from scipy.io import netcdf
import matplotlib.pyplot as plt
import matplotlib
from math import pi, sqrt

######################################################################################3
# There are 2 main parts to this script:
# 1: Determine the radii to use.
# 2: Determine n, T, and their gradients at these radii.
# 
# We now begin the first of these tasks.
######################################################################################3

def findAvailableRadiiInBC():
    # Parse Joachim Geiger's .bc file format to determine psiAHat, aHat, and the available psiN.
    available_psiN = []
    with open(equilibriumFile, 'r') as f:
        equilibriumFileLines = f.readlines()
    lineNum = 0
    while equilibriumFileLines[lineNum][0:2]=="CC":
        lineNum += 1
    header = equilibriumFileLines[lineNum+1].split()
    psiAHat = float(header[4])/(2*pi)
    aHat = float(header[5])
    print "psiAHat = ",psiAHat
    print "aHat = ",aHat
    for whichLine in range(lineNum+2,len(equilibriumFileLines)):
        if "iota" in equilibriumFileLines[whichLine]:
            available_psiN.append(float(equilibriumFileLines[whichLine+2].split()[0]))
    print "available_psiN:"
    print available_psiN
    return available_psiN

def roundRadii(radii,available_psiN):
    print "Rounding requested radii to match available radii in the magnetic equilibrium file."
    # Both VMEC and .bc formats provide a grid of psiN.
    if inputRadialCoordinate==0:
        # psiHat
        availableRadii = [x*psiAHat for x in available_psiN]
    elif inputRadialCoordinate==1:
        # psiN
        availableRadii = available_psiN
    elif inputRadialCoordinate==2:
        # rHat
        availableRadii = [sqrt(x)*aHat for x in available_psiN]
    elif inputRadialCoordinate==3:
        # rN
        availableRadii = [sqrt(x) for x in available_psiN]
    else:
        print "Invalid inputRadialCoordinate: ",inputRadialCoordinate

    if inputRadialCoordinate != 1:
        print "Available radii for the selected inputRadialCoordinate:"
        print availableRadii
    roundedRadii = []
    for radius in radii:
        errors = [(radius-x)**2 for x in availableRadii]
        roundedRadii.append(availableRadii[errors.index(min(errors))])
    print "Radii before rounding:"
    print radii
    # Eliminate any duplicates:
    radii = sorted(list(set(roundedRadii)))
    print "Radii after rounding:"
    print radii
    return radii
        

geometryScheme = readVariable("geometryScheme","int")
if geometryScheme==5 or geometryScheme==11 or geometryScheme==12:
    pass
else:
    print "Error! For scans over radius, you must use geometryScheme=5, 11, or 12."
    exit(1)

Nradius = readScanVariable("Nradius","int")
inputRadialCoordinate = readVariable("inputRadialCoordinate","int")
inputRadialCoordinateForGradients = readVariable("inputRadialCoordinateForGradients","int")
#if inputRadialCoordinateForGradients != inputRadialCoordinate:
#    print "Warning: This script will overwrite the requested value of inputRadialCoordinateForGradients to match inputRadialCoordinate."

if inputRadialCoordinate==0:
    radiusName = "psiHat"
elif inputRadialCoordinate==1:
    radiusName = "psiN"
elif inputRadialCoordinate==2:
    radiusName = "rHat"
elif inputRadialCoordinate==3:
    radiusName = "rN"
else:
    print "Error! Invalid inputRadialCoordinate."
    exit(1)

if inputRadialCoordinateForGradients==0:
    radiusNameForGradients = "psiHat"
elif inputRadialCoordinateForGradients==1:
    radiusNameForGradients = "psiN"
elif inputRadialCoordinateForGradients==2:
    radiusNameForGradients = "rHat"
elif inputRadialCoordinateForGradients==3:
    radiusNameForGradients = "rN"
else:
    print "Error! Invalid inputRadialCoordinateForGradients."
    exit(1)

radius_min = readScanVariable(radiusName+"_min","float")
radius_max = readScanVariable(radiusName+"_max","float")
if radius_max <= radius_min:
    print "Error! Minimum requested radius must be < maximum requested radius."
    exit(1)

# Do some basic validation:
if Nradius < 1:
    print "Error! Nradius must be >= 1"
    exit(1)
if inputRadialCoordinate==1 and radius_min<0:
    print "Error! psiN_min must be >= 0."
    exit(1)
elif inputRadialCoordinate==1 and radius_max > 1:
    print "Error! psiN_max must be <= 1."
    exit(1)
elif inputRadialCoordinate==2 and radius_min<0:
    print "Error! rHat_min must be >= 0."
    exit(1)
elif inputRadialCoordinate==3 and radius_min<0:
    print "Error! rN_min must be >= 0."
    exit(1)
elif inputRadialCoordinate==3 and radius_max > 1:
    print "Error! rN_max must be <= 1."
    exit(1)

# First set up a simple uniformly spaced grid.  We may shift these points later.
radii = linspace(radius_min, radius_max, Nradius)

# Next, load the magnetic equilibrium.
# We at least need to determine aHat and psiHat, since these two quantities are
# needed to relate the various definitions of radius.
# We may also need to know the surfaces on which the magnetic equilibrium information
# is available.

equilibriumFile = readVariable("equilibriumFile","string")
equilibriumFile = equilibriumFile[1:-1]

if geometryScheme==11 or geometryScheme==12:
    radii = roundRadii(radii,findAvailableRadiiInBC())

if geometryScheme==5:
    try:
        f = netcdf.netcdf_file(equilibriumFile,'r')
    except:
        print "ERROR! Unable to read VMEC wout equilibrium file."
        print "Presently this script assumes the VMEC file is netCDF format rather than ASCII format,"
        print "so this error may arise if you are using an ASCII wout file."
        raise

    vmec_phi = f.variables['phi'][()]
    # The definition of minor radius is not unique. Presently, SFINCS takes the minor radius aHat to be vmec's Aminor_p:
    aHat = f.variables['Aminor_p'][()]
    f.close()
    psiAHat = vmec_phi[-1]/(2*pi)
    print "vmec-derived aHat: ",aHat
    print "vmec-derived psiAHat: ",psiAHat

    vmecRadialOption = readVariable('vmecRadialOption','int')
    if vmecRadialOption==0:
        # Do not shift radial grid points.
        pass
    elif vmecRadialOption==1:
        # Force use of vmec's half mesh
        dpsi = vmec_phi[1]-vmec_phi[0]
        available_psiN = [(x - dpsi/2)/vmec_phi[-1] for x in vmec_phi[1:]]
        print "available_psiN:"
        print available_psiN
        radii = roundRadii(radii, available_psiN)
    elif vmecRadialOption==2:
        # Force use of vmec's full mesh
        available_psiN = [x / vmec_phi[-1] for x in vmec_phi]
        print "available_psiN:"
        print available_psiN
        radii = roundRadii(radii, available_psiN)
    else:
        print "Error! Invalid vmecRadialOption"


# More validation:
if inputRadialCoordinate==2 and radius_max > aHat:
    print "Error! rHat_max must be <= aHat."
    exit(1)

print "Here are the values of "+radiusName+" we will use for this scan:"
print radii

#exit(0)

directories = [radiusName+"_"+str(radius) for radius in radii]

# For a scan over only radius, we do not want to repeat radii that were already run.
# But for a scan over Er at each radius, we do want to revisit every radius.
if skipExistingDirectories:
    radii_copy = list(radii)
    directories_copy = list(directories)

    # See if any runs with the same description already exist.
    # This happens if you re-run sfincsScan more than once in the same directory.
    for i in range(len(radii_copy)):
        directory = directories_copy[i]
        if os.path.exists(directory):
            print "Warning: directory "+directory+" already exists, so skipping this run."
            radii.remove(radii_copy[i])
            directories.remove(directory)

# For future use, convert radii into psiN:
if inputRadialCoordinate == 0:
    # psiHat
    radii_psiN = [x/psiAHat for x in radii]
elif inputRadialCoordinate == 1:
    # psiN
    radii_psiN = radii
elif inputRadialCoordinate == 2:
    # rHat
    radii_psiN = [(x/aHat)**2 for x in radii]
elif inputRadialCoordinate == 3:
    # rN
    radii_psiN = [x**2 for x in radii]
else:
    print "ERROR! Should not get here."
    exit(1)

######################################################################################3
# At this point, the radii have been finalized.
# Now move on to the second phase of the problem: determining n and T (and their
# gradients) on these radii.
######################################################################################3


# Determine the number of species according to the input.namelist file:
Zs = readVariable('Zs','string')
Zs = Zs.split()
Nspecies = len(Zs)
for i in range(Nspecies):
    Zs[i] = float(Zs[i])
if Nspecies != len(readVariable('mHats','string').split()):
    print "Error! Number of species is not consistent among Zs and mHats in input.namelist."
    exit(1)
print "Number of species determined from the input.namelist file: ",Nspecies

def convertGradients():
    # Given d(n or T)HatdpsiN, multiply by gradientFactor to convert to dnHatd(inputRadialCoordinateForGradients) 
    if inputRadialCoordinateForGradients == 0:
        # psiHat
        gradientFactor = [1.0/psiAHat for psiN in radii_psiN]
        gradientFactorFine = [1.0/psiAHat for psiN in psiN_fine]
    elif inputRadialCoordinateForGradients == 1:
        # psiN
        gradientFactor = [1.0 for psiN in radii_psiN]
        gradientFactorFine = [1.0 for psiN in psiN_fine]
    elif inputRadialCoordinateForGradients == 2:
        # rHat
        gradientFactor = [2*sqrt(psiN) for psiN in radii_psiN]
        gradientFactorFine = [2*sqrt(psiN) for psiN in psiN_fine]
    elif inputRadialCoordinateForGradients == 3:
        # rN
        gradientFactor = [2*sqrt(psiN)/aHat for psiN in radii_psiN]
        gradientFactorFine = [2*sqrt(psiN)/aHat for psiN in psiN_fine]
    else:
        print "ERROR! Should not get here."
        exit(1)
    
    for ispecies in range(Nspecies):
        thisSpecies_dnHatdradii = []
        thisSpecies_dTHatdradii = []
        thisSpecies_dnHatdradii_fine = []
        thisSpecies_dTHatdradii_fine = []
        for ir in range(len(radii)):
            thisSpecies_dnHatdradii.append(dnHatdpsiN[ispecies][ir]*gradientFactor[ir])
            thisSpecies_dTHatdradii.append(dTHatdpsiN[ispecies][ir]*gradientFactor[ir])
        for ir in range(len(psiN_fine)):
            thisSpecies_dnHatdradii_fine.append(dnHatdpsiN_fine[ispecies][ir]*gradientFactorFine[ir])
            thisSpecies_dTHatdradii_fine.append(dTHatdpsiN_fine[ispecies][ir]*gradientFactorFine[ir])
        dnHatdradii.append(thisSpecies_dnHatdradii)
        dTHatdradii.append(thisSpecies_dTHatdradii)
        dnHatdradii_fine.append(thisSpecies_dnHatdradii_fine)
        dTHatdradii_fine.append(thisSpecies_dTHatdradii_fine)

def plotProposedProfiles():
    # Plot the input profiles and their derivatives.
    # All the arrays dnHatdradii, dnHatdradii_fine, etc should be populated before this function is called.
    fig = plt.figure()
    fig.patch.set_facecolor('white')
    # Set the default color cycle:
    matplotlib.rcParams['axes.color_cycle'] = ['b', 'r', 'c','y','g','k']
    if Nspecies>1:
        numQuantities = 2*(2*Nspecies+2)+2
    else:
        numQuantities = 6
    numCols = math.ceil(math.sqrt(numQuantities*1.0))
    numRows = math.ceil(numQuantities*1.0/numCols)
    plotNum = 1

    if profilesScheme==1:
        fineLabel="spline through data"
    else:
        fineLabel="data polynomial"

    plt.subplot(numRows,numCols,plotNum)
    plt.plot(radii_fine,NErs_fine,'-',label=fineLabel)
    plt.plot(radii,NErs,'x',label="requested")
    if profilesScheme==1:
        plt.plot(data_radius,data_NErs,'.',label="data")
    plt.xlabel(radiusName)
    plt.title("NErs")
    plt.legend(loc=0, borderaxespad=0., prop={'size':9})
    plotNum += 1

    plt.subplot(numRows,numCols,plotNum)
    plt.plot(radii_fine,dPhiHatdradius_min_fine,'-b',label=fineLabel)
    plt.plot(radii,dPhiHatdradius_min,'xr',label="requested")
    if profilesScheme==1:
        plt.plot(data_radius,data_dPhiHatdradius_min,'.c',label="data")
    plt.plot(radii_fine,dPhiHatdradius_max_fine,'-b',label=fineLabel)
    plt.plot(radii,dPhiHatdradius_max,'xr',label="requested")
    if profilesScheme==1:
        plt.plot(data_radius,data_dPhiHatdradius_max,'.c',label="data")
    plt.xlabel(radiusName)
    plt.title("Max and min dPhiHatd"+radiusNameForGradients)
    plt.legend(loc=0, borderaxespad=0., prop={'size':9})
    plotNum += 1

    if Nspecies>1:
        # Plot nHat for all species on 1 plot:
        plt.subplot(numRows,numCols,plotNum)
        for ispecies in range(Nspecies):
            plt.plot(radii_fine,nHats_fine[ispecies],'-',label="Species "+str(ispecies+1))
        plt.xlabel(radiusName)
        plt.title("nHats")
        plotNum += 1
        plt.legend(loc=0, borderaxespad=0., prop={'size':9})

        # Plot dnHatdradius for all species on 1 plot:
        plt.subplot(numRows,numCols,plotNum)
        for ispecies in range(Nspecies):
            plt.plot(radii_fine,dnHatdradii_fine[ispecies],'-',label="Species "+str(ispecies+1))
        plt.xlabel(radiusName)
        plt.title("dnHatd"+radiusNameForGradients+"s")
        plotNum += 1

        # Plot THat for all species on 1 plot:
        plt.subplot(numRows,numCols,plotNum)
        for ispecies in range(Nspecies):
            plt.plot(radii_fine,THats_fine[ispecies],'-',label="Species "+str(ispecies+1))
        plt.xlabel(radiusName)
        plt.title("THats")
        plotNum += 1

        # Plot dTHatdradius for all species on 1 plot:
        plt.subplot(numRows,numCols,plotNum)
        for ispecies in range(Nspecies):
            plt.plot(radii_fine,dTHatdradii_fine[ispecies],'-',label="Species "+str(ispecies+1))
        plt.xlabel(radiusName)
        plt.title("dTHatd"+radiusNameForGradients+"s")
        plotNum += 1

    # Plot nHat
    for ispecies in range(Nspecies):
        plt.subplot(numRows,numCols,plotNum)
        plt.plot(radii_fine,nHats_fine[ispecies],'-',label=fineLabel)
        plt.plot(radii, nHats[ispecies],'x',label="requested")
        if profilesScheme==1:
            plt.plot(data_radius,data_nHats[ispecies],'.',label="data")
        if ispecies==0:
            plt.legend(loc=0, borderaxespad=0., prop={'size':9})
        plotNum += 1
        plt.xlabel(radiusName)
        plt.title("nHat, species "+str(ispecies+1)+" (Z="+str(Zs[ispecies])+")")

    # Plot d(nHat)/d(radius)
    for ispecies in range(Nspecies):
        plt.subplot(numRows,numCols,plotNum)
        #plt.plot(data_radius_half,dnHatdradii_finiteDifference[ispecies],'.',label="finite difference")
        plt.plot(radii_fine,dnHatdradii_fine[ispecies],'-',label=fineLabel)
        plt.plot(radii, dnHatdradii[ispecies],'x',label="requested")
        plotNum += 1
        plt.xlabel(radiusName)
        plt.title("dnHatd"+radiusNameForGradients+", species "+str(ispecies+1)+" (Z="+str(Zs[ispecies])+")")

    # Plot THat
    for ispecies in range(Nspecies):
        plt.subplot(numRows,numCols,plotNum)
        plt.plot(radii_fine,THats_fine[ispecies],'-',label=fineLabel)
        plt.plot(radii, THats[ispecies],'x',label="requested")
        if profilesScheme==1:
            plt.plot(data_radius,data_THats[ispecies],'.',label="data")
        plotNum += 1
        plt.xlabel(radiusName)
        plt.title("THat, species "+str(ispecies+1)+" (Z="+str(Zs[ispecies])+")")

    # Plot d(THat)/d(radius)
    for ispecies in range(Nspecies):
        plt.subplot(numRows,numCols,plotNum)
        #plt.plot(data_radius_half,dTHatdradii_finiteDifference[ispecies],'.',label="finite difference")
        plt.plot(radii_fine,dTHatdradii_fine[ispecies],'-',label=fineLabel)
        plt.plot(radii, dTHatdradii[ispecies],'x',label="requested")
        plotNum += 1
        plt.xlabel(radiusName)
        plt.title("dTHatd"+radiusNameForGradients+", species "+str(ispecies+1)+" (Z="+str(Zs[ispecies])+")")

    titleString = "Profiles to use for radial scan.\nPlot generated by "+ inspect.getfile(inspect.currentframe()) + "\nRun in "+os.getcwd()
    ax = fig.add_axes([0,0,1,1], frameon=False)
    ax.text(0.5,0.99,titleString,horizontalalignment='center',verticalalignment='top')
    plt.show(block=False)


# Read in profile information.
try:
    with open(profilesFilename, 'r') as f:
        profilesFile = f.readlines()
except:
    print "ERROR! Unable to read profiles file."
    raise

profilesScheme = readScanVariable("profilesScheme","int")
dnHatdradii = []
dTHatdradii = []
dnHatdradii_fine = []
dTHatdradii_fine = []
if profilesScheme == 1:
    #####################################################
    # Read in n and T for each species on a grid.
    #####################################################
    data_radius = []
    data_nHats = []
    data_THats = []
    data_NErs = []
    data_dPhiHatdradius_min = []
    data_dPhiHatdradius_max = []
    for i in range(Nspecies):
        data_nHats.append([])
        data_THats.append([])
    readRadialCoordinateYet = False
    for line in profilesFile:
        line = line.strip().lower()
        if line[0] == '!' or line[0] == '#':
            continue
        if not readRadialCoordinateYet:
            # This must be the first non-comment line in the file.
            readRadialCoordinateYet = True
            if line != 'psihat' and line != 'psin' and line != 'rhat' and line != 'rn':
                print "ERROR!  The first non-comment line in the 'profiles' file must be the radial coordinate (psiHat, psiN, rHat, or rN)"
                exit(1)
            profilesRadialCoordinate = line
            continue
        print line.split()
        if Nspecies*2+4 != len(line.split()):
            print "Error! Each line in the profiles file should have 2*Nspecies+4 values. The following line seems to have the wrong number of values:"
            print line
            exit(1)
        lineSplit = line.split()
        try:
            data_radius.append(float(lineSplit[0]))
            data_NErs.append(float(lineSplit[1]))
            data_dPhiHatdradius_min.append(float(lineSplit[2]))
            data_dPhiHatdradius_max.append(float(lineSplit[3]))
            for i in range(Nspecies):
                data_nHats[i].append(float(lineSplit[2*i+4]))
                data_THats[i].append(float(lineSplit[2*i+5]))
        except:
            print "Error parsing the following line of the profiles file:"
            print line
            raise

    print "Here are the radial coordinates read from the profiles file:"
    print data_radius
    for i in range(Nspecies):
        print "Here comes the data for nHat of species "+str(i+1)+" read from the profiles file:"
        print data_nHats[i]
        print "Here comes the data for THat of species "+str(i+1)+" read from the profiles file:"
        print data_THats[i]

    # Convert radii from the profiles file into psiN:
    #radii_fine = numpy.linspace(min(data_radius), max(data_radius), 200)
    if profilesRadialCoordinate == 'psihat':
        data_psiN = [x/psiAHat for x in data_radius]
        #psiN_fine = [x/psiAHat for x in radii_fine]
    elif profilesRadialCoordinate == 'psin':
        data_psiN = data_radius
        #psiN_fine = radii_fine
    elif profilesRadialCoordinate == 'rhat':
        data_psiN = [(x/aHat)**2 for x in data_radius]
        #psiN_fine = [(x/aHat)**2 for x in radii_fine]
    elif profilesRadialCoordinate == 'rn':
        data_psiN = [x**2 for x in data_radius]
        #psiN_fine = [x**2 for x in radii_fine]
    else:
        print "ERROR! Should not get here."
        exit(1)

    # Convert data radii from psiN to inputRadialCoordinate:
    psiN_fine = numpy.linspace(min(data_psiN), max(data_psiN), 200)
    if inputRadialCoordinate == 0:
        # psiHat
        data_radius = [x*psiAHat for x in data_psiN]
        radii_fine  = [x*psiAHat for x in psiN_fine]
    elif inputRadialCoordinate == 1:
        # psiN
        data_radius = data_psiN
        radii_fine  = psiN_fine
    elif inputRadialCoordinate == 2:
        # rHat
        data_radius = [aHat*sqrt(x) for x in data_psiN]
        radii_fine  = [aHat*sqrt(x) for x in psiN_fine]
    elif inputRadialCoordinate == 3:
        # rN
        data_radius = [sqrt(x) for x in data_psiN]
        radii_fine = [sqrt(x) for x in psiN_fine]
    else:
        print "ERROR! Should not get here."
        exit(1)

    # Interpolate profiles onto the requested points:
    nHats = []
    nHats_fine = []
    THats = []
    THats_fine = []
    dnHatdpsiN = []
    dnHatdpsiN_fine = []
    dTHatdpsiN = []
    dTHatdpsiN_fine = []
    NErs = []
    NErs_fine = []
    dPhiHatdradius_max = []
    dPhiHatdradius_max_fine = []
    dPhiHatdradius_min = []
    dPhiHatdradius_min_fine = []
    #data_radius_half = []
    #for iradius in range (1,len(data_radius)):
    #    data_radius_half.append((data_radius[iradius-1]+data_radius[iradius])/2)
    #dnHatdradii_finiteDifference = []
    #dTHatdradii_finiteDifference = []
    for ispecies in range(Nspecies):
        #dnHatdradius_finiteDifference = []
        #dTHatdradius_finiteDifference = []
        #for ir in range(1,len(data_radius)):
        #    dnHatdradius_finiteDifference.append((data_nHats[ispecies][ir]-data_nHats[ispecies][ir-1]) / (data_radius[ir]-data_radius[ir-1]))
        #    dTHatdradius_finiteDifference.append((data_THats[ispecies][ir]-data_THats[ispecies][ir-1]) / (data_radius[ir]-data_radius[ir-1]))
        #dnHatdradii_finiteDifference.append(dnHatdradius_finiteDifference)
        #dTHatdradii_finiteDifference.append(dTHatdradius_finiteDifference)

        # Fit a cubic spline. See http://docs.scipy.org/doc/scipy/reference/tutorial/interpolate.html
        #interpolator = interpolate.splrep(data_radius, data_nHats[ispecies], s=0)
        interpolator = interpolate.splrep(data_psiN, data_nHats[ispecies])
        if len(radii)>0:
            # The if/else block is here because interpolate.splev fails if new grid is empty.
            nHats.append(interpolate.splev(radii_psiN,interpolator, der=0))
            dnHatdpsiN.append(interpolate.splev(radii_psiN,interpolator, der=1))
        else:
            nHats.append([])
            dnHatdradii.append([])
        nHats_fine.append(interpolate.splev(psiN_fine,interpolator, der=0))
        dnHatdpsiN_fine.append(interpolate.splev(psiN_fine,interpolator, der=1))

        interpolator = interpolate.splrep(data_psiN, data_THats[ispecies])
        if len(radii)>0:
            # The if/else block is here because interpolate.splev fails if new grid is empty.
            THats.append(interpolate.splev(radii_psiN,interpolator, der=0))
            dTHatdpsiN.append(interpolate.splev(radii_psiN,interpolator, der=1))
        else:
            THats.append([])
            dTHatdpsiN.append([])
        THats_fine.append(interpolate.splev(psiN_fine,interpolator, der=0))
        dTHatdpsiN_fine.append(interpolate.splev(psiN_fine,interpolator, der=1))

    interpolator = interpolate.splrep(data_psiN, data_NErs)
    if len(radii)>0:
        # The if/else block is here because interpolate.splev fails if new grid is empty.
        NErs = [int(round(x)) for x in interpolate.splev(radii_psiN,interpolator, der=0)]
    else:
        NErs = []
    NErs_fine = interpolate.splev(psiN_fine,interpolator, der=0)

    interpolator = interpolate.splrep(data_psiN, data_dPhiHatdradius_min)
    if len(radii)>0:
        # The if/else block is here because interpolate.splev fails if new grid is empty.
        dPhiHatdradius_min = interpolate.splev(radii_psiN,interpolator, der=0)
    else:
        dPhiHatdradius_min = []
    dPhiHatdradius_min_fine = interpolate.splev(psiN_fine,interpolator, der=0)

    interpolator = interpolate.splrep(data_psiN, data_dPhiHatdradius_max)
    if len(radii)>0:
        # The if/else block is here because interpolate.splev fails if new grid is empty.
        dPhiHatdradius_max = interpolate.splev(radii_psiN,interpolator, der=0)
    else:
        dPhiHatdradius_max = []
    dPhiHatdradius_max_fine = interpolate.splev(psiN_fine,interpolator, der=0)

    convertGradients()
    plotProposedProfiles()

elif profilesScheme == 2:
    # Need code here...
    
    convertGradients()
    plotProposedProfiles()
else:
    print "Error! profilesScheme must be set to 1 or 2."
    exit(1)








print
print "Here are the directories that will be created:"
print directories

